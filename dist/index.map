{"version":3,"sources":["misc-functions\\context.ts","misc-functions\\creators.ts","consts.ts","misc-functions\\namespace.ts","misc-functions\\group-resources.ts","misc-functions\\file-errors.ts","brigadier\\errors.ts","types.ts","misc-functions\\return-helper.ts","misc-functions\\promisified-fs.ts","misc-functions\\third_party\\typed-keys.ts","misc-functions\\datapack-folder.ts","misc-functions\\translation.ts","misc-functions\\lsp-conversions.ts","misc-functions\\node-tree.ts","data\\cache.ts","misc-functions\\security.ts","misc-functions\\setup.ts","misc-functions\\parsing\\namespace.ts","misc-functions\\parsing\\nmsp-tag.ts","misc-functions\\index.ts","brigadier\\string-reader.ts","parsers\\brigadier\\bool.ts","parsers\\brigadier\\string.ts","parsers\\brigadier\\integer.ts","parsers\\brigadier\\float.ts","parsers\\brigadier\\index.ts","parsers\\literal.ts","parsers\\minecraft\\block.ts","parsers\\minecraft\\coordinates.ts","parsers\\minecraft\\item.ts","colors.ts","data\\lists\\item-slot.ts","data\\lists\\scoreboard-slot.ts","data\\lists\\statics.ts","parsers\\minecraft\\lists.ts","parsers\\minecraft\\message.ts","parsers\\minecraft\\namespace-list.ts","parsers\\minecraft\\resources.ts","parsers\\minecraft\\scoreboard.ts","parsers\\get-parser.ts","completions.ts","data\\extractor\\mapfunctions.ts","data\\nbt\\buffer-stream.ts","data\\nbt\\parser.ts","data\\nbt\\nbt-cache.ts","data\\datapack-resources.ts","data\\extractor\\collect-data.ts","data\\extractor\\download.ts","data\\extractor\\extract-data.ts","data\\extractor\\index.ts","data\\noncached.ts","data\\manager.ts","misc-functions\\third_party\\merge-deep.ts","parse.ts","index.ts"],"names":[],"mappings":"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A,UAAY,CACrB,kCACA,2BACA,oBACA,kBACA,mBACA,kBACA,iBACA,6BACA,0BACA,0BACA,2BACA,iBACA,mBACA,2BACA,0BACA,oBACA,oBACA,0BACA,8BACA,sBACA,yBACA,qBACA,oBACA,kBACA,2BACA,kBACA,2BACA,iBACA,uBACA,0BACA,wBACA,iBACA,qBACA,iBACA,iBACA,mBACA,iBACA,kBACA,iBACA,sBACA,yBACA,6BACA,uBACA,mBACA,kBACA,uBACA,yBACA,6BACA,sBAGS,QAAA,SAAW,CACpB,oBACA,cACA,QACA,MACA,QACA,OACA,cACA,UACA,MACA,MACA,UACA,SACA,UACA,kBACA,UACA,iBACA,cACA,eACA,WACA,YACA,eACA,SACA,iBACA,eACA,gBACA,kBACA,QACA,QACA,WACA,QACA,OACA,aACA,OACA,aACA,WACA,aACA,QACA,aACA,aACA,WACA,iBACA,yBACA,mBACA,kBACA,mBACA,eACA,OACA,YACA,SACA,WACA,SACA,MACA,aACA,gBACA,aACA,MACA,SACA,SACA,QACA,UACA,iBACA,aACA,WACA,iBACA,QACA,iBACA,aACA,WACA,iBACA,SACA,QACA,QACA,gBACA,SACA,MACA,cACA,oBACA,SACA,MACA,WACA,aACA,aACA,QACA,SACA,kBACA,eACA,OACA,SACA,eACA,kBACA,UACA,iBACA,WAGS,QAAA,WAAa,CAAC,YAAa,aAAc;;AC1JzC,aAAA,OAAA,eAAA,QAAA,aAAA,CAAA,OAAA,IAtEb,MAAA,EAAA,QAAA,yBACA,EAAA,QAAA,0BAEA,EAAA,QAAA,gBACA,EAAA,QAAA,8BACA,EAAA,QAAA,oCACA,EAAA,QAAA,4BACA,EAAA,QAAA,wBAGA,MAAa,EAIU,YAAA,EAAmB,GAC7B,KAAA,QAAU,EACV,KAAA,MAAQ,EAIb,MAAA,EACA,GAEM,MAAA,EAAQ,EAAO,OACf,EAAS,IAAI,EAAA,aAAa,GAC1B,EAAY,EAAO,WACrB,KAAK,SACL,EACA,EAAA,mBAAmB,WACnB,MAEA,OAAA,EAAO,MAAM,GACN,EAAO,UAE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","file":"index.map","sourceRoot":"..\\src","sourcesContent":["import { CommandNodePath } from \"../data/types\";\n\nexport interface ContextPath<T> {\n    data: T;\n    path: CommandNodePath;\n}\n\nexport function resolvePaths<T>(\n    paths: Array<ContextPath<T>>,\n    argPath: CommandNodePath\n): T | undefined {\n    for (const path of paths) {\n        if (stringArrayEqual(argPath, path.path)) {\n            return path.data;\n        }\n    }\n    return undefined;\n}\n\nfunction stringArrayEqual(arr1: string[], arr2: string[]): boolean {\n    return arr1.length === arr2.length && arr1.every((v, i) => v === arr2[i]);\n}\n\nexport function startPaths<T>(\n    paths: Array<ContextPath<T>>,\n    argpath: CommandNodePath\n): T | undefined {\n    let best: [number, T?] = [0, undefined];\n    for (const option of paths) {\n        if (\n            option.path.length > best[0] &&\n            option.path.length <= argpath.length &&\n            option.path.every((v, i) => v === argpath[i])\n        ) {\n            best = [option.path.length, option.data];\n        }\n    }\n    return best[1];\n}\n","import { CommandNode, CommandNodePath } from \"../data/types\";\nimport {\n    CommandContext,\n    CommandLine,\n    CommmandData,\n    ParserInfo\n} from \"../types\";\n\n/**\n * Build parser info from the data required\n */\nexport function createParserInfo(\n    node: CommandNode,\n    data: CommmandData,\n    path: CommandNodePath,\n    context: CommandContext,\n    suggesting: boolean\n): ParserInfo {\n    const result: ParserInfo = {\n        context,\n        data,\n        node_properties: node.properties || {},\n        path,\n        suggesting\n    };\n    return result;\n}\n\n/**\n * Convert a string into CommandLines based on newline characters\n */\nexport function splitLines(text: string): CommandLine[] {\n    return createCommandLines(text.split(/\\r?\\n/));\n}\n\n/**\n * Convert the given string array into a blank CommandLine Array\n */\nexport function createCommandLines(lines: string[]): CommandLine[] {\n    const result: CommandLine[] = [];\n    for (const line of lines) {\n        result.push({ text: line });\n    }\n    return result;\n}\n","export const COMMENT_START = \"#\";\nexport const SPACE = \" \";\n\n// Namespaces\nexport const DEFAULT_NAMESPACE = \"minecraft\";\nexport const NAMESPACE = \":\";\nexport const DATAFOLDER = \"data\";\nexport const SLASH = \"/\";\nexport const MCMETAFILE = \"pack.mcmeta\";\n\n// Blocks\nexport const TAG_START = \"#\";\n","import { DEFAULT_NAMESPACE, NAMESPACE } from \"../consts\";\nimport { NamespacedName } from \"../data/types\";\n\nexport function namespacesEqual(\n    first: NamespacedName,\n    second: NamespacedName\n): boolean {\n    return namesEqual(first, second) && first.path === second.path;\n}\n\nexport function namesEqual(\n    first: NamespacedName,\n    second: NamespacedName\n): boolean {\n    return (\n        first.namespace === second.namespace ||\n        (isNamespaceDefault(first) && isNamespaceDefault(second))\n    );\n}\n\nexport function isNamespaceDefault(name: NamespacedName): boolean {\n    return name.namespace === undefined || name.namespace === DEFAULT_NAMESPACE;\n}\n\nexport function stringifyNamespace(namespace: NamespacedName): string {\n    return (\n        (namespace.namespace ? namespace.namespace : DEFAULT_NAMESPACE) +\n        NAMESPACE +\n        namespace.path\n    );\n}\n\nexport function convertToNamespace(\n    input: string,\n    splitChar: string = NAMESPACE\n): NamespacedName {\n    const index = input.indexOf(splitChar);\n    if (index >= 0) {\n        const pathContents = input.substring(\n            index + splitChar.length,\n            input.length\n        );\n        // Path contents should not have a : in the contents, however this is to be checked higher up.\n        // This simplifies using the parsed result when parsing options\n\n        // Related: https://bugs.mojang.com/browse/MC-91245 (Fixed)\n        if (index >= 1) {\n            return { namespace: input.substring(0, index), path: pathContents };\n        } else {\n            return { path: pathContents };\n        }\n    } else {\n        return { path: input };\n    }\n}\n","import {\n    GlobalData,\n    MinecraftResource,\n    NamespacedName,\n    Resources,\n    WorldInfo\n} from \"../data/types\";\nimport { CommmandData } from \"../types\";\nimport { namespacesEqual } from \"./namespace\";\n\nexport function getResourcesofType<\n    T extends MinecraftResource = MinecraftResource\n>(resources: CommmandData, type: keyof Resources): T[] {\n    return getResourcesSplit<T>(\n        type,\n        resources.globalData,\n        resources.localData\n    );\n}\n\nexport function getResourcesSplit<\n    T extends MinecraftResource = MinecraftResource\n>(type: keyof Resources, globalData: GlobalData, packsInfo?: WorldInfo): T[] {\n    const results: MinecraftResource[] = [];\n    const globalResources = globalData.resources[type];\n    if (!!globalResources) {\n        results.push(...globalResources);\n    }\n    if (packsInfo) {\n        for (const packId in packsInfo.packs) {\n            if (packsInfo.packs.hasOwnProperty(packId)) {\n                const pack = packsInfo.packs[packId];\n                if (pack.data.hasOwnProperty(type)) {\n                    const data = pack.data[type];\n                    if (!!data) {\n                        results.push(...data);\n                    }\n                }\n            }\n        }\n    }\n    return results as T[];\n}\n\nexport function getMatching<T extends NamespacedName>(\n    resources: T[],\n    value: T\n): T[] {\n    const results: T[] = [];\n    for (const resource of resources) {\n        if (namespacesEqual(resource, value)) {\n            results.push(resource);\n        }\n    }\n    return results;\n}\n","import { MiscInfo } from \"../types\";\n\nexport function createExtensionFileError(\n    filePath: string,\n    expected: string,\n    actual: string\n): MiscInfo {\n    return {\n        filePath,\n        group: \"extension\",\n        kind: \"FileError\",\n        message: `File has incorrect extension: Expected ${expected}, got ${actual}.`\n    };\n}\n\nexport function createJSONFileError(filePath: string, error: any): MiscInfo {\n    return {\n        filePath,\n        group: \"json\",\n        kind: \"FileError\",\n        message: `JSON parsing failed: '${error}'`\n    };\n}\n\nexport function createFileClear(filePath: string, group?: string): MiscInfo {\n    return { kind: \"ClearError\", filePath, group };\n}\n","import { DiagnosticSeverity } from \"vscode-languageserver/lib/main\";\nimport { MCFormat } from \"../misc-functions\";\n\n/**\n * A blank command error\n */\nexport interface BlankCommandError {\n    /**\n     * The code of this error, usable for translation?\n     */\n    code: string;\n    /**\n     * The severity of this error.\n     */\n    severity: DiagnosticSeverity;\n    /**\n     * The substitutions to insert into the error text.\n     */\n    substitutions?: string[];\n    /**\n     * The cached text of this error.\n     */\n    text: string;\n}\n\n/**\n * An error inside a command.\n */\nexport interface CommandError extends BlankCommandError {\n    /**\n     * The range of this error.\n     */\n    range: {\n        end: number;\n        start: number;\n    };\n}\n\n/**\n * Helper class to create command errors\n */\nexport class CommandErrorBuilder {\n    private readonly code: string;\n    private readonly default: string;\n    private readonly severity: DiagnosticSeverity;\n\n    public constructor(\n        code: string,\n        explanation: string,\n        severity: DiagnosticSeverity = DiagnosticSeverity.Error\n    ) {\n        this.code = code;\n        this.default = explanation;\n        this.severity = severity;\n    }\n\n    public create(\n        start: number,\n        end: number,\n        ...substitutions: string[]\n    ): CommandError {\n        const diagnosis: CommandError = Object.assign(\n            this.createBlank(...substitutions),\n            { range: { start, end } }\n        );\n        return diagnosis;\n    }\n\n    public createBlank(...substitutions: string[]): BlankCommandError {\n        return {\n            code: this.code,\n            severity: this.severity,\n            substitutions,\n            text: MCFormat(this.default, ...substitutions)\n        };\n    }\n}\n\n/**\n * Transform `err` into a real command error.\n * MODIFIES `err`\n * @param err The error to transform\n * @param start The starting location in the line of the error\n * @param end The end position\n */\nexport function fillBlankError(\n    err: BlankCommandError,\n    start: number,\n    end: number\n): CommandError {\n    return { ...err, range: { start, end } };\n}\n","import { DataInterval, Interval, IntervalTree } from \"node-interval-tree\";\nimport {\n    CompletionItemKind,\n    MarkedString\n} from \"vscode-languageserver/lib/main\";\nimport { BlankCommandError, CommandError } from \"./brigadier/errors\";\nimport { StringReader } from \"./brigadier/string-reader\";\nimport { CommandNodePath, GlobalData, LocalData } from \"./data/types\";\nimport { PackLocationSegments } from \"./misc-functions\";\n\n//#region Document\nexport interface FunctionInfo {\n    lines: CommandLine[];\n    /**\n     * The filesystem path to the `datapacks` folder this is part of - NOT the folder of the single datapack\n     */\n    pack_segments: PackLocationSegments | undefined;\n}\n\nexport interface WorkspaceSecurity {\n    // CustomParsers?: boolean;\n    JarPath?: boolean;\n    JavaPath?: boolean;\n}\n\nexport interface CommandLine {\n    /**\n     * A cache of the tree of actions\n     */\n    actions?: IntervalTree<SubAction>;\n    nodes?: IntervalTree<ParseNode>;\n    parseInfo?: StoredParseResult | false;\n    text: string;\n}\n//#endregion\n\n//#region Interaction with parsers\nexport interface ParserInfo {\n    /**\n     * The immutable context\n     */\n    context: CommandContext;\n    data: CommmandData;\n    node_properties: Dictionary<any>;\n    path: CommandNodePath; // Will be > 0\n    /**\n     * When suggesting, the end of the reader's string will be the cursor position\n     */\n    suggesting: boolean;\n}\n\nexport interface CommmandData {\n    globalData: GlobalData;\n    /**\n     * Data from datapacks\n     */\n    localData?: LocalData;\n}\n\nexport interface Suggestion {\n    description?: string;\n    kind?: CompletionItemKind;\n    /**\n     * The start from where value should be replaced. 0 indexed character gaps.\n     * E.g. `@e[na` with the suggestion `{value:\"name=\",start:3}`\n     * would make `@e[name=` when accepted.\n     */\n    start: number;\n    text: string;\n}\n\nexport type SuggestResult = Suggestion | string;\n\n/**\n * A change to the shared context\n */\nexport type ContextChange = Partial<CommandContext> | undefined;\n\nexport interface CommandContext {\n    /**\n     * Whether the executor is definitely a player.\n     * (Currently unused)\n     */\n    isPlayer?: boolean;\n    [key: string]: any;\n}\n\nexport interface Parser {\n    /**\n     * The default suggestion kind for suggestions from this parser\n     */\n    kind?: CompletionItemKind;\n    /**\n     * Parse the argument as described in NodeProperties against this parser in the reader.\n     * Gets both suggestions and success\n     */\n    parse(\n        reader: StringReader,\n        properties: ParserInfo\n    ): ReturnedInfo<ContextChange | undefined>;\n}\n\n//#endregion\n//#region ParsingData\nexport interface ParseNode extends Interval {\n    context: CommandContext;\n    final: boolean;\n    path: CommandNodePath;\n}\n\nexport interface StoredParseResult {\n    actions: SubAction[];\n    errors: CommandError[];\n    nodes: ParseNode[];\n}\n\ninterface SubActionBase<U extends string, T> extends DataInterval<T> {\n    type: U;\n}\n\nexport type SubAction =\n    // See https://github.com/Microsoft/language-server-protocol/issues/518.\n    | SubActionBase<\"hover\", MarkedString>\n    | SubActionBase<\"format\", string>\n    | SubActionBase<\"source\", string>;\n// | SubActionBase<\"rename\", RenameRequest>;\n//#endregion\nexport type Success = true;\nexport const success: Success = true;\n\nexport const failure: Failure = false;\nexport type Failure = false;\n\n//#region ReturnData\nexport interface ReturnData<ErrorKind extends BCE = CE> {\n    actions: SubAction[];\n    errors: ErrorKind[];\n    /**\n     * Points not related to a specific line being parsed.\n     * This includes errors inside a file for example.\n     */\n    misc: MiscInfo[];\n    suggestions: SuggestResult[];\n}\n\ntype MiscInfoBase<kind extends string, value> = value & {\n    kind: kind;\n};\n\nexport type MiscInfo =\n    | MiscInfoBase<\"FileError\", FileError>\n    | MiscInfoBase<\"ClearError\", ClearFileError>;\n\ninterface FileError {\n    filePath: string;\n    group: string;\n    message: string;\n}\n\ninterface ClearFileError {\n    filePath: string;\n    group?: string;\n}\n\n/**\n * A general return type which can either succeed or fail, bringing other data\n */\nexport type ReturnedInfo<T, ErrorKind extends BCE = CE, E = undefined> =\n    | ReturnSuccess<T, ErrorKind>\n    | ReturnFailure<E, ErrorKind>;\n\nexport interface ReturnFailure<K = undefined, ErrorKind extends BCE = CE>\n    extends ReturnData<ErrorKind> {\n    data: K;\n    kind: Failure;\n}\n\nexport interface ReturnSuccess<T, ErrorKind extends BCE = CE>\n    extends ReturnData<ErrorKind> {\n    data: T;\n    kind: Success;\n}\n//#endregion\n// Helper types to lower the amount of repetition of the names\nexport type BCE = BlankCommandError;\nexport type CE = CommandError;\n","import {\n    BlankCommandError,\n    CommandError,\n    fillBlankError\n} from \"../brigadier/errors\";\nimport {\n    BCE,\n    CE,\n    Failure,\n    failure,\n    MiscInfo,\n    ParserInfo,\n    ReturnData,\n    ReturnedInfo,\n    ReturnFailure,\n    ReturnSuccess,\n    SubAction,\n    success,\n    Success,\n    Suggestion,\n    SuggestResult\n} from \"../types\";\n\n/**\n * Create an instance of the common return type\n */\nfunction createReturn<ErrorKind extends BCE = CE>(): ReturnData<ErrorKind> {\n    return { actions: [], errors: [], suggestions: [], misc: [] };\n}\n\n/**\n * Test if `input` is successful\n * @param input The info to test\n */\nexport function isSuccessful<T, E extends BCE = CE>(\n    input: ReturnedInfo<T, E, any>\n): input is ReturnSuccess<T, E> {\n    return input.kind === success;\n}\n\n/**\n * Fill the blank errors in data with 'real' errors\n * MODIFIES `data`\n * @param data The data to modify\n * @param start The starting position of the area the errors should cover\n * @param end The end position\n */\nexport function fillBlanks<T>(\n    data: ReturnedInfo<T, BCE>,\n    start: number,\n    end: number\n): ReturnedInfo<T>;\nexport function fillBlanks(\n    data: ReturnData<BCE>,\n    start: number,\n    end: number\n): ReturnData {\n    const errors = [];\n    for (const err of data.errors) {\n        errors.push(fillBlankError(err, start, end));\n    }\n    return { ...data, errors };\n}\n\nexport class ReturnHelper<Errorkind extends BlankCommandError = CommandError> {\n    private readonly data: ReturnData<Errorkind> = createReturn<Errorkind>();\n    private readonly suggesting?: boolean;\n\n    public constructor(suggesting?: ParserInfo | boolean) {\n        if (typeof suggesting !== \"undefined\") {\n            if (typeof suggesting === \"boolean\") {\n                this.suggesting = suggesting;\n                return;\n            }\n            this.suggesting = suggesting.suggesting;\n        }\n    }\n\n    public addActions(...actions: SubAction[]): this {\n        if (this.suggesting === undefined || !this.suggesting) {\n            this.data.actions.push(...actions);\n        }\n        return this;\n    }\n\n    public addErrors(...errs: Errorkind[]): this {\n        if (this.suggesting === undefined || !this.suggesting) {\n            this.data.errors.push(...errs);\n        }\n        return this;\n    }\n\n    public addFileErrorIfFalse(\n        option: boolean,\n        filePath: string,\n        group: string,\n        message: string\n    ): option is true {\n        if (!option) {\n            this.addMisc({ group, message, filePath, kind: \"FileError\" });\n        } else {\n            this.addMisc({ group, filePath, kind: \"ClearError\" });\n        }\n        return option;\n    }\n    public addMisc(...others: MiscInfo[]): this {\n        if (this.suggesting === undefined || !this.suggesting) {\n            this.data.misc.push(...others);\n        }\n        return this;\n    }\n\n    public addSuggestion(\n        start: number,\n        text: string,\n        kind?: Suggestion[\"kind\"],\n        description?: string\n    ): this {\n        if (this.suggesting === undefined || this.suggesting) {\n            this.addSuggestions({\n                description,\n                kind,\n                start,\n                text\n            });\n        }\n        return this;\n    }\n    public addSuggestions(...suggestions: SuggestResult[]): this {\n        if (this.suggesting === undefined || this.suggesting) {\n            this.data.suggestions.push(...suggestions);\n        }\n        return this;\n    }\n\n    public fail(err?: Errorkind): ReturnFailure<undefined, Errorkind> {\n        if (!!err && !this.suggesting) {\n            this.addErrors(err);\n        }\n        return {\n            ...this.getShared(),\n            kind: failure as Failure\n        } as ReturnFailure<undefined, Errorkind>;\n    }\n\n    public failWithData<T>(data: T): ReturnFailure<T, Errorkind> {\n        return { ...this.getShared(), data, kind: failure as Failure };\n    }\n    public getShared(): ReturnData<Errorkind> {\n        return this.data;\n    }\n\n    public merge<T>(\n        merge: ReturnedInfo<T, Errorkind, any>,\n        suggestOverride?: boolean\n    ): merge is ReturnSuccess<T, Errorkind> {\n        this.mergeChain(merge, suggestOverride);\n        return isSuccessful(merge);\n    }\n\n    public mergeChain(\n        merge: ReturnedInfo<any, Errorkind>,\n        suggestOverride?: boolean\n    ): this {\n        let suggest: boolean | undefined;\n        if (suggestOverride !== undefined) {\n            suggest = suggestOverride;\n        } else {\n            if (this.suggesting !== undefined) {\n                suggest = this.suggesting;\n            }\n        }\n        switch (suggest) {\n            case true:\n                this.mergeSuggestions(merge);\n                break;\n            case false:\n                this.mergeSafe(merge);\n                break;\n            default:\n                this.mergeSuggestions(merge);\n                this.mergeSafe(merge);\n        }\n        return this;\n    }\n\n    public return<T, E>(\n        other: ReturnedInfo<T, Errorkind, E>\n    ): ReturnedInfo<T, Errorkind, E> {\n        if (this.merge(other)) {\n            return this.succeed(other.data);\n        } else {\n            return this.failWithData(other.data);\n        }\n    }\n\n    public succeed<T extends undefined>(\n        data?: T\n    ): ReturnSuccess<undefined, Errorkind>;\n    public succeed<T>(data: T): ReturnSuccess<T, Errorkind>;\n    public succeed<T>(data: T): ReturnSuccess<T, Errorkind> {\n        return { ...this.getShared(), data, kind: success as Success };\n    }\n\n    private mergeSafe(merge: ReturnData<Errorkind>): void {\n        this.addActions(...merge.actions);\n        this.addErrors(...merge.errors);\n        this.addMisc(...merge.misc);\n    }\n\n    private mergeSuggestions(merge: ReturnData<Errorkind>): void {\n        this.addSuggestions(...merge.suggestions);\n    }\n}\n\nexport function prepareForParser(\n    info: ReturnedInfo<any>,\n    suggesting: boolean | ParserInfo\n): ReturnedInfo<undefined> {\n    const helper = new ReturnHelper(suggesting);\n    if (helper.merge(info)) {\n        return helper.succeed();\n    } else {\n        return helper.fail();\n    }\n}\n","import * as fs from \"fs\";\nimport * as path from \"path\";\nimport { shim } from \"util.promisify\";\nshim();\nimport { promisify } from \"util\";\nimport { ReturnedInfo } from \"../types\";\nimport { createJSONFileError } from \"./file-errors\";\nimport { ReturnHelper } from \"./return-helper\";\n\nexport const readFileAsync = promisify(fs.readFile);\nexport const saveFileAsync = promisify(fs.writeFile);\nexport const mkdirAsync = promisify(fs.mkdir);\nexport const readDirAsync = promisify(fs.readdir);\nexport const statAsync = promisify(fs.stat);\n\nexport async function readJSONRaw<T>(filePath: string): Promise<T> {\n    const buffer = await readFileAsync(filePath);\n    return JSON.parse(buffer.toString());\n}\n\nexport async function writeJSON(filepath: string, o: object): Promise<void> {\n    await saveFileAsync(filepath, JSON.stringify(o, undefined, 4));\n}\n\nexport async function readJSON<T>(filePath: string): Promise<ReturnedInfo<T>> {\n    const helper = new ReturnHelper();\n    let buffer: Buffer;\n    try {\n        buffer = await readFileAsync(filePath);\n    } catch (error) {\n        mcLangLog(`File at '${filePath}' not available: ${error}`);\n        return helper.fail();\n    }\n    try {\n        const result = JSON.parse(buffer.toString());\n        return helper.succeed<T>(result);\n    } catch (e) {\n        return helper.addMisc(createJSONFileError(filePath, e)).fail();\n    }\n}\n\nexport async function walkDir(currentPath: string): Promise<string[]> {\n    const subFolders: string[] = [];\n    try {\n        subFolders.push(...(await readDirAsync(currentPath)));\n    } catch (error) {\n        return [];\n    }\n    const promises = subFolders.map(async sub => {\n        try {\n            const files: string[] = [];\n            const subFile = path.join(currentPath, sub);\n            if ((await statAsync(subFile)).isDirectory()) {\n                files.push(...(await walkDir(subFile)));\n            } else {\n                files.push(subFile);\n            }\n            return files;\n        } catch (error) {\n            return [];\n        }\n    });\n    const results = await Promise.all(promises);\n    return ([] as string[]).concat(...results);\n}\n","/**\n * Get the keys of the object in a way friendly to\n * the typescript compiler.\n * Taken from https://github.com/Microsoft/TypeScript/pull/12253#issuecomment-353494273\n * @param o The object to get the keys of.\n */\nexport function typed_keys<O>(o: O): Array<keyof O> {\n    return Object.keys(o) as Array<keyof O>;\n}\n","import * as defaultPath from \"path\";\nimport { DATAFOLDER, SLASH, TAG_START } from \"../consts\";\nimport {\n    DataResource,\n    GlobalData,\n    MinecraftResource,\n    NamespacedName,\n    Resources,\n    Tag,\n    WorldInfo\n} from \"../data/types\";\nimport { ReturnSuccess } from \"../types\";\nimport { getMatching, getResourcesSplit } from \"./group-resources\";\nimport { convertToNamespace } from \"./namespace\";\nimport { readJSON } from \"./promisified-fs\";\nimport { ReturnHelper } from \"./return-helper\";\nimport { typed_keys } from \"./third_party/typed-keys\";\n\n/** A minimal path module for use in this file */\ntype PathModule = Pick<\n    typeof import(\"path\").posix, // N.B. `.posix` is required.\n    \"extname\" | \"sep\" | \"format\" | \"isAbsolute\" | \"join\" | \"normalize\" | \"parse\"\n>;\n\nexport interface PackLocationSegments {\n    pack: string;\n    packsFolder: string;\n    rest: string;\n}\n\n/**\n * Find the datapacks folder a file is in.\n * @param fileLocation The URI of the file\n * @param path The path module to use (allows for testing).\n */\nexport function parseDataPath(\n    fileLocation: string,\n    path: PathModule = defaultPath\n): PackLocationSegments | undefined {\n    const parsed = path.parse(path.normalize(fileLocation));\n    const dirs = parsed.dir.split(path.sep);\n    const packsFolderIndex = dirs.indexOf(\"datapacks\");\n    if (packsFolderIndex !== -1) {\n        const remainder = dirs.slice(packsFolderIndex + 1);\n        if (remainder.length >= 1) {\n            let packsFolder = path.join(...dirs.slice(0, packsFolderIndex + 1));\n            // Ugly hack because path.join ignores a leading empty dir, leading to the result of\n            // `/home/datapacks` going to `home/datapacks`\n            if (path.sep === \"/\" && !path.isAbsolute(packsFolder)) {\n                packsFolder = path.sep + packsFolder;\n            }\n            packsFolder = path.format({ dir: packsFolder });\n            const rest = path.join(...remainder.slice(1), parsed.base);\n            return { packsFolder, pack: remainder[0], rest };\n        }\n    }\n    return undefined;\n}\n\ninterface ResourceInfo<U extends keyof Resources> {\n    extension: string;\n    path: [U] | string[]; // Custom tuple improves autocomplete mostly.\n    mapFunction?(\n        value: NonNullable<Resources[U]> extends Array<infer T> ? T : never,\n        packroot: string,\n        globalData: GlobalData,\n        packsInfo?: WorldInfo\n    ): Promise<ReturnSuccess<typeof value>>;\n}\n\nexport const resourceTypes: { [T in keyof Resources]-?: ResourceInfo<T> } = {\n    advancements: { extension: \".json\", path: [\"advancements\"] },\n    block_tags: {\n        extension: \".json\",\n        mapFunction: async (v, packroot, globalData, packsInfo) =>\n            readTag(\n                v,\n                packroot,\n                \"block_tags\",\n                getResourcesSplit(\"block_tags\", globalData, packsInfo),\n                s => globalData.blocks.hasOwnProperty(s)\n            ),\n        path: [\"tags\", \"blocks\"]\n    },\n    function_tags: {\n        extension: \".json\",\n        mapFunction: async (v, packroot, globalData, packsInfo) => {\n            const functions = getResourcesSplit(\n                \"functions\",\n                globalData,\n                packsInfo\n            );\n            return readTag(\n                v,\n                packroot,\n                \"function_tags\",\n                getResourcesSplit(\"function_tags\", globalData, packsInfo),\n                s => getMatching(functions, convertToNamespace(s)).length > 0\n            );\n        },\n        path: [\"tags\", \"functions\"]\n    },\n    functions: { extension: \".mcfunction\", path: [\"functions\"] },\n    item_tags: {\n        extension: \".json\",\n        mapFunction: async (v, packroot, globalData, packsInfo) =>\n            readTag(\n                v,\n                packroot,\n                \"item_tags\",\n                getResourcesSplit(\"item_tags\", globalData, packsInfo),\n                s => globalData.items.indexOf(s) !== -1\n            ),\n        path: [\"tags\", \"items\"]\n    },\n    loot_tables: { extension: \".json\", path: [\"loot_tables\"] },\n    recipes: { extension: \".json\", path: [\"recipes\"] },\n    structures: { extension: \".nbt\", path: [\"structures\"] }\n};\n\ninterface KindNamespace {\n    kind: keyof Resources;\n    location: NamespacedName & { namespace: string };\n}\n\nexport function getKindAndNamespace(\n    rest: string,\n    path: PathModule = defaultPath\n): KindNamespace | undefined {\n    const sections = path.normalize(rest).split(path.sep);\n    if (sections[0] === DATAFOLDER && sections.length > 2) {\n        // Namespace,data,\n        const remainder = sections.splice(2);\n        for (const kind of typed_keys(resourceTypes)) {\n            const typeInfo = resourceTypes[kind];\n            if (\n                (typeInfo.path as string[]).every((v, i) => remainder[i] === v)\n            ) {\n                const namespace = sections[1];\n                const further = remainder.slice(typeInfo.path.length);\n                if (further.length > 0) {\n                    const last = further[further.length - 1];\n                    if (path.extname(last) === typeInfo.extension) {\n                        const pth = path\n                            .join(\n                                ...further.slice(0, -1),\n                                last.slice(0, -typeInfo.extension.length)\n                            )\n                            .replace(path.sep, SLASH);\n                        return {\n                            kind,\n                            location: {\n                                namespace,\n                                path: pth\n                            }\n                        };\n                    }\n                }\n            }\n        }\n    }\n    return undefined;\n}\n\nexport function getPath(\n    resource: MinecraftResource,\n    packroot: string,\n    kind: keyof Resources,\n    path: PathModule = defaultPath\n): string {\n    return path.join(\n        packroot,\n        DATAFOLDER,\n        resource.namespace,\n        ...resourceTypes[kind].path,\n        resource.path\n            .replace(SLASH, path.sep)\n            .concat(resourceTypes[kind].extension)\n    );\n}\n\nexport function buildPath(\n    resource: MinecraftResource,\n    packs: WorldInfo,\n    kind: keyof Resources,\n    path: PathModule = defaultPath\n): string | undefined {\n    if (resource.pack) {\n        const pack = packs.packs[resource.pack];\n        return getPath(\n            resource,\n            path.join(packs.location, pack.name),\n            kind,\n            path\n        );\n    } else {\n        return undefined;\n    }\n}\n\nasync function readTag(\n    resource: MinecraftResource,\n    packRoot: string,\n    type: keyof Resources,\n    options: MinecraftResource[],\n    isKnown: (value: string) => boolean\n): Promise<ReturnSuccess<DataResource<Tag> | MinecraftResource>> {\n    const helper = new ReturnHelper();\n    const filePath = getPath(resource, packRoot, type);\n    const tag = await readJSON<Tag>(filePath);\n    if (helper.merge(tag)) {\n        if (\n            helper.addFileErrorIfFalse(\n                !!tag.data.values,\n                filePath,\n                \"InvalidTagNoValues\",\n                `tag does not have a values key: ${JSON.stringify(tag.data)}`\n            )\n        ) {\n            if (\n                helper.addFileErrorIfFalse(\n                    Array.isArray(tag.data.values),\n                    filePath,\n                    \"InvalidTagValuesNotArray\",\n                    `tag values is not an array: ${JSON.stringify(\n                        tag.data.values\n                    )}`\n                )\n            ) {\n                if (\n                    helper.addFileErrorIfFalse(\n                        // tslint:disable-next-line:strict-type-predicates\n                        tag.data.values.every(v => typeof v === \"string\"),\n                        filePath,\n                        \"InvalidTagValuesNotString\",\n                        `tag values contains a non string value: ${JSON.stringify(\n                            tag.data.values\n                        )}`\n                    )\n                ) {\n                    const seen = new Set<string>();\n                    const duplicates = new Set<string>();\n                    const unknowns = new Set<string>();\n                    for (const value of tag.data.values) {\n                        if (seen.has(value)) {\n                            duplicates.add(value);\n                        }\n                        seen.add(value);\n                        if (value.startsWith(TAG_START)) {\n                            const result = getMatching(\n                                options,\n                                convertToNamespace(value)\n                            );\n                            if (result.length === 0) {\n                                unknowns.add(value);\n                            }\n                        } else if (!isKnown(value)) {\n                            unknowns.add(value);\n                        }\n                    }\n                    helper.addFileErrorIfFalse(\n                        duplicates.size === 0,\n                        filePath,\n                        \"InvalidTagValuesDuplicates\",\n                        `Tag contains duplicate values: \"${[...duplicates].join(\n                            '\", \"'\n                        )}\"`\n                    );\n                    helper.addFileErrorIfFalse(\n                        unknowns.size === 0,\n                        filePath,\n                        \"InvalidTagValuesUnknown\",\n                        `Tag contains unknown values: \"${[...unknowns].join(\n                            '\", \"'\n                        )}\"`\n                    );\n                    return helper.succeed({\n                        ...resource,\n                        data: tag.data\n                    });\n                }\n            }\n        }\n    }\n    return helper.succeed(resource);\n}\n","import { vsprintf } from \"sprintf-js\";\n\nexport function shouldTranslate(): boolean {\n    return mcLangSettings.translation.lang.toLowerCase() !== \"en-us\";\n}\n\nexport function MCFormat(base: string, ...substitutions: string[]): string {\n    return vsprintf(base, substitutions);\n}\n","import {\n    Diagnostic,\n    DidChangeTextDocumentParams,\n    Range\n} from \"vscode-languageserver/lib/main\";\nimport { CommandError } from \"../brigadier/errors\";\nimport { FunctionInfo } from \"../types\";\nimport { splitLines } from \"./creators\";\nimport { shouldTranslate } from \"./translation\";\n\n/**\n * Turn a command error into a language server diagnostic\n */\nexport function commandErrorToDiagnostic(\n    error: CommandError,\n    line: number\n): Diagnostic {\n    const range: Range = {\n        end: { line, character: error.range.end },\n        start: { line, character: error.range.start }\n    };\n    // Run Translation stuff on the error?\n    const text = shouldTranslate()\n        ? `'${error.text}': Translation is not yet supported` // Translate(error.code)\n        : error.text;\n    return Diagnostic.create(\n        range,\n        text,\n        error.severity,\n        error.code,\n        \"mcfunction\"\n    );\n}\n\nexport function runChanges(\n    changes: DidChangeTextDocumentParams,\n    functionInfo: FunctionInfo\n): number[] {\n    const changed: number[] = [];\n    for (const change of changes.contentChanges) {\n        if (!!change.range) {\n            // Appease the compiler, as the change interface seems to have range optional\n            const { start, end }: Range = change.range;\n            const newLineContent = functionInfo.lines[start.line].text\n                .substring(0, start.character)\n                .concat(\n                    change.text,\n                    functionInfo.lines[end.line].text.substring(end.character)\n                );\n            const difference = end.line - start.line + 1;\n            const newLines = splitLines(newLineContent);\n            functionInfo.lines.splice(start.line, difference, ...newLines);\n            changed.forEach((v, i) => {\n                if (v > start.line) {\n                    changed[i] = v - difference + newLines.length;\n                }\n            });\n            changed.push(\n                ...Array.from(\n                    new Array(newLines.length),\n                    (_, i) => start.line + i\n                )\n            );\n        }\n    }\n    const unique = changed.filter(\n        (value, index, self) => self.indexOf(value) === index\n    );\n    unique.sort((a, b) => a - b);\n    return unique;\n}\n","import {\n    CommandNode,\n    CommandNodePath,\n    CommandTree,\n    MCNode\n} from \"../data/types\";\n\nexport function followPath<T extends MCNode<T>>(\n    tree: MCNode<T>,\n    path: CommandNodePath\n): MCNode<T> {\n    // There are no protections here, because if a path is given it should be correct.\n    let current = tree;\n    for (const section of path) {\n        if (!!current.children && !!current.children[section]) {\n            current = current.children[section];\n        }\n    }\n    return current;\n}\n\nexport function getNextNode(\n    node:\n        | CommandNode\n        | MCNode<CommandNode> & {\n              executable?: boolean;\n              redirect?: CommandNodePath;\n          }, // Allow use of node.redirect without a tsignore\n    nodePath: CommandNodePath,\n    tree: CommandTree\n): GetNodeResult {\n    const redirect: CommandNodePath | undefined = node.redirect;\n    if (!!redirect) {\n        return { node: followPath(tree, redirect), path: redirect };\n    } else {\n        if (!node.children && !node.executable) {\n            // In this case either tree is malformed or in `execute run`\n            // So we just return the entire tree\n            return { node: tree, path: [] };\n        }\n        return { node, path: nodePath };\n    }\n}\n\ninterface GetNodeResult {\n    node: MCNode<CommandNode>;\n    path: CommandNodePath;\n}\n","import * as path from \"path\";\n\nimport {\n    mkdirAsync,\n    readJSONRaw,\n    saveFileAsync,\n    writeJSON\n} from \"../misc-functions/promisified-fs\";\nimport { typed_keys } from \"../misc-functions/third_party/typed-keys\";\nimport { WorkspaceSecurity } from \"../types\";\nimport { Cacheable } from \"./types\";\n\nif (!process.env.MCFUNCTION_CACHE_DIR) {\n    throw new Error(\"Environment variable MCFUNCTION_CACHE_DIR must be set\");\n}\nconst cacheFolder = process.env.MCFUNCTION_CACHE_DIR;\n\nconst cacheFileNames: { [K in keyof Cacheable]: string } = {\n    blocks: \"blocks.json\",\n    commands: \"commands.json\",\n    items: \"items.json\",\n    meta_info: \"meta_info.json\",\n    resources: \"resources.json\"\n};\n\nexport async function readCache(): Promise<Cacheable> {\n    const data: Cacheable = {} as Cacheable;\n    const keys = typed_keys(cacheFileNames);\n    await Promise.all(\n        keys.map(async key => {\n            data[key] = await readJSONRaw<Cacheable[typeof key]>(\n                path.join(cacheFolder, cacheFileNames[key])\n            );\n        })\n    );\n    return data;\n}\n\nexport async function cacheData(data: Cacheable): Promise<void> {\n    try {\n        await mkdirAsync(cacheFolder, \"777\");\n    } catch (_) {\n        // Don't use the error, which is normally thrown if the folder doesn't exist\n    }\n    const keys: Array<keyof typeof cacheFileNames> = typed_keys(cacheFileNames);\n    await Promise.all(\n        keys.map(async key =>\n            writeJSON(path.join(cacheFolder, cacheFileNames[key]), data[key])\n        )\n    );\n    return;\n}\n\nexport async function storeSecurity(\n    security: WorkspaceSecurity\n): Promise<void> {\n    await saveFileAsync(\n        path.join(cacheFolder, \"security.json\"),\n        JSON.stringify(security)\n    );\n}\n\nexport async function readSecurity(): Promise<WorkspaceSecurity> {\n    try {\n        return await readJSONRaw(path.join(cacheFolder, \"security.json\"));\n    } catch (error) {\n        return {};\n    }\n}\n","import { IConnection } from \"vscode-languageserver/lib/main\";\nimport { storeSecurity } from \"../data/cache\";\nimport { WorkspaceSecurity } from \"../types\";\n\n/**\n * Check if the given change requires security confirmation\n */\nexport function securityIssues(\n    settings: McFunctionSettings,\n    security: WorkspaceSecurity\n): Array<keyof WorkspaceSecurity> {\n    const results: Array<keyof WorkspaceSecurity> = [];\n    if (!!settings.data) {\n        if (!!settings.data.customJar && security.JarPath !== true) {\n            results.push(\"JarPath\");\n        }\n        if (!!settings.data.javaPath && security.JavaPath !== true) {\n            results.push(\"JavaPath\");\n        }\n    }\n    if (!!settings.parsers /* && security.CustomParsers !== true */) {\n        /* const names = Object.keys(settings.parsers);\n        if (names.length > 0) {\n            results.push(\"CustomParsers\");\n        } */\n        throw new Error(`Custom parsers are not supported for client implementations.\nTo request this feature be enabled, open an issue at https://github.com/Levertion/mcfunction-langserver`);\n    }\n    return results;\n}\n\nexport async function actOnSecurity(\n    issues: Array<keyof WorkspaceSecurity>,\n    connection: IConnection,\n    security: WorkspaceSecurity\n): Promise<boolean> {\n    let securityChanged = false;\n    const resave = async () => {\n        if (securityChanged) {\n            await storeSecurity(security);\n        }\n    };\n    for (const issue of issues) {\n        const response = await Promise.resolve(\n            connection.window.showErrorMessage(\n                `[MCFUNCTION] You have the potentially insecure setting '${issue}' set, but no confirmation has been recieved.`,\n                { title: \"Yes\" },\n                { title: \"No (Stops server)\" }\n            )\n        );\n        if (!!response && response.title === \"Yes\") {\n            security[issue] = true;\n            securityChanged = true;\n        } else {\n            return false;\n        }\n    }\n    await resave();\n    return true;\n}\n","import { IConnection } from \"vscode-languageserver/lib/main\";\n\nexport function setup_logging(connection: IConnection): void {\n    const log = (message: string) => {\n        connection.console.log(message);\n    };\n    // tslint:disable-next-line:prefer-object-spread\n    global.mcLangLog = Object.assign(log, {\n        internal: (m: string) => {\n            if (mcLangSettings.trace.internalLogging) {\n                log(`[McFunctionInternal] ${m}`);\n            }\n        }\n    });\n}\n","import { CompletionItemKind } from \"vscode-languageserver/lib/main\";\nimport {\n    convertToNamespace,\n    namespacesEqual,\n    ReturnHelper,\n    stringifyNamespace\n} from \"..\";\nimport { CommandErrorBuilder } from \"../../brigadier/errors\";\nimport { StringReader } from \"../../brigadier/string-reader\";\nimport { NamespacedName } from \"../../data/types\";\nimport { CE, ReturnedInfo, ReturnSuccess, Suggestion } from \"../../types\";\nimport { isNamespaceDefault, namesEqual } from \"../namespace\";\n\nconst NAMESPACEEXCEPTIONS = {\n    invalid_id: new CommandErrorBuilder(\n        \"argument.id.invalid\",\n        \"Invalid character '%s' in location %s\"\n    )\n};\n\nconst allowedPath = /[^a-z0-9_.-]/g;\n\nexport function readNamespaceText(reader: StringReader): string {\n    const namespaceChars = /^[0-9a-z_:/\\.-]$/;\n    return reader.readWhileRegexp(namespaceChars);\n}\n\n/**\n * Does `base`(eg minecraft:stone) start with `test` (e.g. sto) [Y]\n */\nexport function namespaceStart(\n    base: NamespacedName,\n    test: NamespacedName\n): boolean {\n    if (test.namespace === undefined) {\n        return (\n            (isNamespaceDefault(base) && base.path.startsWith(test.path)) ||\n            (!!base.namespace && base.namespace.startsWith(test.path))\n        );\n    } else {\n        return namesEqual(base, test) && base.path.startsWith(test.path);\n    }\n}\n\nexport function namespaceSuggestions(\n    options: NamespacedName[],\n    value: NamespacedName,\n    start: number\n): Suggestion[] {\n    const result: Suggestion[] = [];\n    for (const option of options) {\n        if (namespaceStart(option, value)) {\n            result.push({ text: stringifyNamespace(option), start });\n        }\n    }\n    return result;\n}\n\nexport function namespaceSuggestionString(\n    options: string[],\n    value: NamespacedName,\n    start: number\n): Suggestion[] {\n    return namespaceSuggestions(\n        // tslint:disable-next-line:no-unnecessary-callback-wrapper this is a false positive - see https://github.com/palantir/tslint/issues/2430\n        options.map(v => convertToNamespace(v)),\n        value,\n        start\n    );\n}\n\nexport function parseNamespace(\n    reader: StringReader\n): ReturnedInfo<NamespacedName> {\n    const helper = new ReturnHelper();\n    const start = reader.cursor;\n    const text = readNamespaceText(reader);\n    const namespace = convertToNamespace(text);\n    let next: RegExpExecArray | null;\n    let failed = false;\n    // Give an error for each invalid character\n    do {\n        next = allowedPath.exec(namespace.path);\n        if (next) {\n            // Relies on the fact that convertToNamespace splits on the first\n            const i = text.indexOf(\":\") + 1 + next.index + start;\n            failed = true;\n            helper.addErrors(\n                NAMESPACEEXCEPTIONS.invalid_id.create(i, i + 1, next[0], text)\n            );\n        }\n    } while (next);\n    if (failed) {\n        return helper.fail();\n    } else {\n        return helper.succeed(namespace);\n    }\n}\n\ninterface OptionResult<T> {\n    literal: NamespacedName;\n    values: T[];\n}\n\nexport function parseNamespaceOption<T extends NamespacedName>(\n    reader: StringReader,\n    options: T[],\n    completionKind?: CompletionItemKind\n): ReturnedInfo<OptionResult<T>, CE, NamespacedName | undefined> {\n    const helper = new ReturnHelper();\n    const start = reader.cursor;\n    const namespace = parseNamespace(reader);\n    if (helper.merge(namespace)) {\n        const results = processParsedNamespaceOption(\n            namespace.data,\n            options,\n            !reader.canRead(),\n            start,\n            completionKind\n        );\n        helper.merge(results);\n        if (results.data.length > 0) {\n            return helper.succeed<OptionResult<T>>({\n                literal: namespace.data,\n                values: results.data\n            });\n        } else {\n            return helper.failWithData(namespace.data);\n        }\n    } else {\n        return helper.failWithData(undefined);\n    }\n}\n\nexport function processParsedNamespaceOption<T extends NamespacedName>(\n    namespace: NamespacedName,\n    options: T[],\n    suggest: boolean,\n    start: number,\n    completionKind?: CompletionItemKind\n): ReturnSuccess<T[]> {\n    const results: T[] = [];\n    const helper = new ReturnHelper();\n    for (const val of options) {\n        if (namespacesEqual(val, namespace)) {\n            results.push(val);\n        }\n        if (suggest && namespaceStart(val, namespace)) {\n            helper.addSuggestion(\n                start,\n                stringifyNamespace(val),\n                completionKind\n            );\n        }\n    }\n    return helper.succeed(results);\n}\n","import { CompletionItemKind } from \"vscode-languageserver/lib/main\";\nimport {\n    buildPath,\n    convertToNamespace,\n    getResourcesofType,\n    namespacesEqual,\n    ReturnHelper\n} from \"..\";\nimport { CommandErrorBuilder } from \"../../brigadier/errors\";\nimport { StringReader } from \"../../brigadier/string-reader\";\nimport { TAG_START } from \"../../consts\";\nimport {\n    DataResource,\n    NamespacedName,\n    Resources,\n    Tag,\n    WorldInfo\n} from \"../../data/types\";\nimport { CE, ParserInfo, ReturnedInfo, ReturnSuccess } from \"../../types\";\nimport {\n    parseNamespace,\n    parseNamespaceOption,\n    readNamespaceText\n} from \"./namespace\";\n\nexport interface TagParseResult {\n    parsed: NamespacedName;\n    resolved?: NamespacedName[];\n    values?: Array<DataResource<Tag>>;\n}\n\n/**\n * Parse a namespace or tag.\n * Returned:\n *  - values are the resources which are the exact matches\n *  - resolved are the lowest level tag members\n *  - parsed is the literal tag. If parsed exists, but not resolved/values, then it was a non-tag\n *  - if not successful, if data undefined then parsing failed.\n *  - if data is a value, then a tag parsed but was unknown\n */\nexport function parseNamespaceOrTag(\n    reader: StringReader,\n    info: ParserInfo,\n    taghandling: keyof Resources | CommandErrorBuilder\n): ReturnedInfo<TagParseResult, CE, NamespacedName | undefined> {\n    const helper = new ReturnHelper(info);\n    const start = reader.cursor;\n    if (reader.peek() === TAG_START) {\n        reader.skip();\n        if (typeof taghandling === \"string\") {\n            const tags: Array<DataResource<Tag>> = getResourcesofType(\n                info.data,\n                taghandling\n            );\n            const parsed = parseNamespaceOption(\n                reader,\n                tags,\n                CompletionItemKind.Folder\n            );\n            if (helper.merge(parsed)) {\n                const values = parsed.data.values;\n                const resolved: NamespacedName[] = [];\n                for (const value of values) {\n                    resolved.push(...getLowestForTag(value, tags));\n                }\n                return helper.succeed<TagParseResult>({\n                    parsed: parsed.data.literal,\n                    resolved,\n                    values\n                });\n            } else {\n                return helper.failWithData(parsed.data);\n            }\n        } else {\n            readNamespaceText(reader);\n            return helper.fail(taghandling.create(start, reader.cursor));\n        }\n    } else {\n        if (!reader.canRead() && typeof taghandling === \"string\") {\n            helper.addSuggestion(\n                reader.cursor,\n                TAG_START,\n                CompletionItemKind.Operator\n            );\n        }\n        const parsed = parseNamespace(reader);\n        if (helper.merge(parsed)) {\n            return helper.succeed({ parsed: parsed.data });\n        } else {\n            return helper.fail();\n        }\n    }\n}\n\nfunction getLowestForTag(\n    tag: DataResource<Tag>,\n    options: Array<DataResource<Tag>>\n): NamespacedName[] {\n    if (!tag.data) {\n        return [];\n    }\n    const results: NamespacedName[] = [];\n    for (const tagMember of tag.data.values) {\n        if (tagMember[0] === TAG_START) {\n            const namespace = convertToNamespace(tagMember.substring(1));\n            for (const option of options) {\n                if (namespacesEqual(namespace, option)) {\n                    results.push(...getLowestForTag(option, options));\n                }\n            }\n        } else {\n            results.push(convertToNamespace(tagMember));\n        }\n    }\n    return results;\n}\n\nexport function buildTagActions(\n    tags: Array<DataResource<Tag>>,\n    low: number,\n    high: number,\n    type: keyof Resources,\n    localData?: WorldInfo\n): ReturnSuccess<void> {\n    const helper = new ReturnHelper();\n    for (const resource of tags) {\n        if (resource.data) {\n            helper.addActions({\n                data: `\\`\\`\\`json\n${JSON.stringify(resource.data, undefined, 4)}\n\\`\\`\\``,\n                high,\n                low,\n                type: \"hover\"\n            });\n        }\n        if (localData) {\n            const location = buildPath(resource, localData, type);\n            if (location) {\n                helper.addActions({\n                    data: location,\n                    high,\n                    low,\n                    type: \"source\"\n                });\n            }\n        }\n    }\n    return helper.succeed();\n}\n","export * from \"./context\";\nexport * from \"./creators\";\nexport * from \"./datapack-folder\";\nexport * from \"./file-errors\";\nexport * from \"./group-resources\";\nexport * from \"./lsp-conversions\";\nexport * from \"./namespace\";\nexport * from \"./node-tree\";\nexport * from \"./promisified-fs\";\nexport * from \"./return-helper\";\nexport * from \"./security\";\nexport * from \"./setup\";\nexport * from \"./translation\";\n\nexport * from \"./parsing/namespace\";\nexport * from \"./parsing/nmsp-tag\";\n","import { CompletionItemKind } from \"vscode-languageserver/lib/main\";\nimport { ReturnHelper } from \"../misc-functions\";\nimport { typed_keys } from \"../misc-functions/third_party/typed-keys\";\nimport { CE, ReturnedInfo, Suggestion } from \"../types\";\nimport { CommandErrorBuilder } from \"./errors\";\n\nconst EXCEPTIONS = {\n    EXPECTED_BOOL: new CommandErrorBuilder(\n        \"parsing.bool.expected\",\n        \"Expected bool\"\n    ),\n    EXPECTED_END_OF_QUOTE: new CommandErrorBuilder(\n        \"parsing.quote.expected.end\",\n        \"Unclosed quoted string\"\n    ),\n    EXPECTED_FLOAT: new CommandErrorBuilder(\n        \"parsing.float.expected\",\n        \"Expected float\"\n    ),\n    EXPECTED_INT: new CommandErrorBuilder(\n        \"parsing.int.expected\",\n        \"Expected integer\"\n    ),\n    EXPECTED_START_OF_QUOTE: new CommandErrorBuilder(\n        \"parsing.quote.expected.start\",\n        \"Expected quote to start a string\"\n    ),\n    EXPECTED_STRING_FROM: new CommandErrorBuilder(\n        \"parsing.expected.option\",\n        \"Expected string from %s, got '%s'\"\n    ),\n    EXPECTED_SYMBOL: new CommandErrorBuilder(\n        \"parsing.expected\",\n        \"Expected '%s'\"\n    ),\n    INVALID_BOOL: new CommandErrorBuilder(\n        \"parsing.bool.invalid\",\n        \"Invalid bool, expected true or false but found '%s'\"\n    ),\n    INVALID_ESCAPE: new CommandErrorBuilder(\n        \"parsing.quote.escape\",\n        \"Invalid escape sequence '\\\\%s' in quoted string)\"\n    ),\n    INVALID_FLOAT: new CommandErrorBuilder(\n        \"parsing.float.invalid\",\n        \"Invalid float '%s'\"\n    ),\n    INVALID_INT: new CommandErrorBuilder(\n        \"parsing.int.invalid\",\n        \"Invalid integer '%s'\"\n    )\n};\n\nconst QUOTE = '\"';\nconst ESCAPE = \"\\\\\";\n\nexport class StringReader {\n    public static charAllowedInUnquotedString = /^[0-9A-Za-z_\\-\\.+]$/;\n    public static charAllowedNumber = /^[0-9\\-\\.]$/;\n    private static readonly bools = { true: true, false: false };\n    public cursor = 0;\n    public readonly string: string;\n\n    public constructor(stringToRead: string) {\n        this.string = stringToRead;\n    }\n    public canRead(length: number = 1): boolean {\n        return this.cursor + length <= this.string.length;\n    }\n    /**\n     * Require that a specific string follows\n     * @param str The string which should come next\n     */\n    public expect(str: string): ReturnedInfo<undefined> {\n        const helper = new ReturnHelper();\n        if (str.startsWith(this.getRemaining())) {\n            helper.addSuggestions({ text: str, start: this.cursor });\n        }\n        const sub = this.string.substr(this.cursor, str.length);\n        if (sub !== str) {\n            return helper.fail(\n                EXCEPTIONS.EXPECTED_SYMBOL.create(\n                    this.cursor,\n                    Math.min(this.string.length, this.cursor + str.length),\n                    sub,\n                    str\n                )\n            );\n        }\n        this.cursor += str.length;\n        return helper.succeed();\n    }\n    public getRead(): string {\n        return this.string.substring(0, this.cursor);\n    }\n    public getRemaining(): string {\n        return this.string.substring(this.cursor);\n    }\n    public getRemainingLength(): number {\n        return this.string.length - this.cursor;\n    }\n    public getTotalLength(): number {\n        return this.string.length;\n    }\n    public peek(offset: number = 0): string {\n        return this.string.charAt(this.cursor + offset);\n    }\n    public read(): string {\n        return this.string.charAt(this.cursor++);\n    }\n    /**\n     * Read a boolean value from the string\n     */\n    public readBoolean(): ReturnedInfo<boolean> {\n        const helper = new ReturnHelper();\n        const start = this.cursor;\n        const value = this.readOption<keyof typeof StringReader[\"bools\"]>(\n            typed_keys(StringReader.bools),\n            false\n        );\n        if (!helper.merge(value)) {\n            if (value.data !== false) {\n                return helper.fail(\n                    EXCEPTIONS.INVALID_BOOL.create(\n                        start,\n                        this.cursor,\n                        value.data\n                    )\n                );\n            } else {\n                return helper.fail();\n            }\n        }\n        return helper.succeed(StringReader.bools[value.data]);\n    }\n    /**\n     * Read a float from the string\n     */\n    public readFloat(): ReturnedInfo<number> {\n        const helper = new ReturnHelper();\n        const start: number = this.cursor;\n        const readToTest: string = this.readWhileRegexp(\n            StringReader.charAllowedNumber\n        );\n        if (readToTest.length === 0) {\n            return helper.fail(\n                EXCEPTIONS.EXPECTED_FLOAT.create(start, this.string.length)\n            );\n        }\n\n        // The Java readInt throws upon multiple `.`s, but Javascript's doesn't\n\n        if ((readToTest.match(/\\./g) || []).length > 1) {\n            return helper.fail(\n                EXCEPTIONS.INVALID_FLOAT.create(\n                    start,\n                    this.cursor,\n                    this.string.substring(start, this.cursor)\n                )\n            );\n        }\n        try {\n            return helper.succeed(parseFloat(readToTest));\n        } catch (error) {\n            return helper.fail(\n                EXCEPTIONS.INVALID_FLOAT.create(start, this.cursor, readToTest)\n            );\n        }\n    }\n    /**\n     * Read an integer from the string\n     */\n    public readInt(): ReturnedInfo<number> {\n        const helper = new ReturnHelper();\n        const start: number = this.cursor;\n        const readToTest: string = this.readWhileRegexp(\n            StringReader.charAllowedNumber\n        );\n        if (readToTest.length === 0) {\n            return helper.fail(\n                EXCEPTIONS.EXPECTED_INT.create(start, this.string.length)\n            );\n        }\n        // The Java readInt throws upon a `.`, but the regex includes one in brigadier\n        // This handles this case\n        if (readToTest.indexOf(\".\") !== -1) {\n            return helper.fail(\n                EXCEPTIONS.INVALID_INT.create(\n                    start,\n                    this.cursor,\n                    this.string.substring(start, this.cursor)\n                )\n            );\n        }\n        try {\n            return helper.succeed(Number.parseInt(readToTest, 10));\n        } catch (error) {\n            return helper.fail(\n                EXCEPTIONS.INVALID_INT.create(start, this.cursor, readToTest)\n            );\n        }\n    }\n    /**\n     * Expect a string from a selection\n     */\n    public readOption<T extends string>(\n        options: T[],\n        addError: boolean = true,\n        completion?: CompletionItemKind,\n        quoted: \"both\" | \"no\" | \"yes\" = \"both\"\n    ): ReturnedInfo<T, CE, string | false> {\n        const start = this.cursor;\n        const helper = new ReturnHelper();\n        let isquoted = false;\n        if (this.peek() === QUOTE) {\n            isquoted = true;\n        }\n        let resultaux: ReturnedInfo<string>;\n        switch (quoted) {\n            case \"both\":\n                resultaux = this.readString();\n                break;\n            case \"yes\":\n                resultaux = this.readQuotedString();\n                break;\n            case \"no\":\n                resultaux = new ReturnHelper(false).succeed(\n                    this.readUnquotedString()\n                );\n                break;\n            default:\n                resultaux = this.readString();\n        }\n        const result = resultaux;\n        if (!helper.merge(result, false)) {\n            if (isquoted && !this.canRead()) {\n                const remaining = this.string.substring(start + 1);\n                // Note that if there are quotes and backslashes, this will fail\n                helper.addSuggestions(\n                    ...options\n                        .filter(v => v.startsWith(remaining))\n                        .map<Suggestion>(v => ({\n                            kind: completion,\n                            start,\n                            text: `${QUOTE}${v}${QUOTE}`\n                        }))\n                );\n            }\n            return helper.failWithData(false as any);\n        }\n        let valid: T | undefined;\n        for (const option of options) {\n            if (option === result.data) {\n                valid = option;\n            }\n        }\n        if (!this.canRead()) {\n            helper.addSuggestions(\n                ...options\n                    .filter(v => v.startsWith(result.data))\n                    .map<Suggestion>(v => ({\n                        kind: completion,\n                        start,\n                        text:\n                            isquoted || v.includes('\"') || v.includes(\"\\\\\")\n                                ? QUOTE +\n                                  v.replace(\"\\\\\", \"\\\\\\\\\").replace('\"', '\\\\\"') +\n                                  QUOTE\n                                : v\n                    }))\n            );\n        }\n        if (valid) {\n            return helper.succeed(valid);\n        } else {\n            if (addError) {\n                helper.addErrors(\n                    EXCEPTIONS.EXPECTED_STRING_FROM.create(\n                        start,\n                        this.cursor,\n                        JSON.stringify(options),\n                        result.data\n                    )\n                );\n            }\n            return helper.failWithData(result.data);\n        }\n    }\n    /**\n     * Read from the string, returning a string, which, in the original had been surrounded by quotes\n     */\n    public readQuotedString(): ReturnedInfo<string> {\n        const helper = new ReturnHelper();\n        const start = this.cursor;\n        if (!this.canRead()) {\n            return helper.succeed(\"\");\n        }\n        if (this.peek() !== QUOTE) {\n            return helper.fail(\n                EXCEPTIONS.EXPECTED_START_OF_QUOTE.create(\n                    this.cursor,\n                    this.string.length\n                )\n            );\n        }\n        let result = \"\";\n        let escaped = false;\n        while (this.canRead()) {\n            this.skip();\n            const c: string = this.peek();\n            if (escaped) {\n                if (c === QUOTE || c === ESCAPE) {\n                    result += c;\n                    escaped = false;\n                } else {\n                    return helper.fail(\n                        EXCEPTIONS.INVALID_ESCAPE.create(\n                            this.cursor - 1,\n                            this.cursor + 1,\n                            c\n                        )\n                    ); // Includes backslash\n                }\n            } else if (c === ESCAPE) {\n                escaped = true;\n            } else if (c === QUOTE) {\n                this.skip();\n                return helper.succeed(result);\n            } else {\n                result += c;\n            }\n        }\n        helper.addSuggestion(this.cursor, QUOTE); // Always cannot read at this point\n        return helper.fail(\n            EXCEPTIONS.EXPECTED_END_OF_QUOTE.create(start, this.string.length)\n        );\n    }\n    /**\n     * Read a string from the string. If it surrounded by quotes, the quotes are ignored.\n     * The cursor ends on the last character in the string.\n     */\n    public readString(): ReturnedInfo<string> {\n        if (this.canRead() && this.peek() === QUOTE) {\n            return this.readQuotedString();\n        } else {\n            const helper = new ReturnHelper();\n            if (!this.canRead()) {\n                helper.addSuggestions({\n                    start: this.cursor,\n                    text: QUOTE\n                });\n            }\n            return helper.succeed(this.readUnquotedString());\n        }\n    }\n\n    /**\n     * Read a string which is not surrounded by quotes.\n     * Can only contain alphanumerical characters, _,+,. and -\n     */\n    public readUnquotedString(): string {\n        return this.readWhileRegexp(StringReader.charAllowedInUnquotedString);\n    }\n\n    /**\n     * Read the string until a certain regular expression matches the\n     * character under the cursor.\n     * @param exp The Regular expression to test against.\n     */\n    public readUntilRegexp(exp: RegExp): string {\n        return this.readWhileFunction(s => !exp.test(s));\n    }\n    /**\n     * Read while a certain function returns true on each consecutive character starting with the one under the cursor.\n     * In most cases, it is better to use readWhileRegexp.\n     * @param callback The function to use.\n     */\n    public readWhileFunction(callback: (char: string) => boolean): string {\n        const begin = this.cursor;\n        while (callback(this.peek())) {\n            if (this.canRead()) {\n                this.skip();\n            } else {\n                return this.string.substring(begin);\n            }\n        }\n        return this.string.substring(begin, this.cursor);\n    }\n    /**\n     * Read the string while a certain regular expression matches the character under the cursor.\n     * The cursor ends on the first character which doesn't match\n     * @param exp The Regular Expression to test against\n     */\n    public readWhileRegexp(exp: RegExp): string {\n        return this.readWhileFunction(s => exp.test(s));\n    }\n\n    public skip(): void {\n        this.cursor++;\n    }\n    public skipWhitespace(): void {\n        this.readWhileRegexp(/\\s/); // Whitespace\n    }\n}\n","import { CompletionItemKind } from \"vscode-languageserver/lib/main\";\nimport { prepareForParser } from \"../../misc-functions\";\nimport { Parser } from \"../../types\";\n\nexport const boolParser: Parser = {\n    kind: CompletionItemKind.Keyword,\n    parse: (reader, props) => prepareForParser(reader.readBoolean(), props)\n};\n","import { ReturnHelper } from \"../../misc-functions\";\nimport { Parser } from \"../../types\";\n\nexport const stringParser: Parser = {\n    parse: (reader, properties) => {\n        const helper = new ReturnHelper(properties);\n        switch (properties.node_properties.type) {\n            case \"greedy\":\n                reader.cursor = reader.string.length;\n                return helper.succeed();\n            case \"word\":\n                reader.readUnquotedString();\n                return helper.succeed();\n            default:\n                if (helper.merge(reader.readString())) {\n                    return helper.succeed();\n                } else {\n                    return helper.fail();\n                }\n        }\n    }\n};\n","import { CommandErrorBuilder } from \"../../brigadier/errors\";\nimport { ReturnHelper } from \"../../misc-functions\";\nimport { Parser } from \"../../types\";\n\nconst JAVAMAXINT = 2147483647;\nconst JAVAMININT = -2147483648;\n\nconst INTEGEREXCEPTIONS = {\n    TOOBIG: new CommandErrorBuilder(\n        \"argument.integer.big\",\n        \"Integer must not be more than %s, found %s\"\n    ),\n    TOOSMALL: new CommandErrorBuilder(\n        \"argument.integer.low\",\n        \"Integer must not be less than %s, found %s\"\n    )\n};\n\nexport const intParser: Parser = {\n    parse: (reader, properties) => {\n        const helper = new ReturnHelper(properties);\n        const start = reader.cursor;\n        const result = reader.readInt();\n        if (!helper.merge(result)) {\n            return helper.fail();\n        }\n        const maxVal = properties.node_properties.max;\n        const minVal = properties.node_properties.min;\n        // See https://stackoverflow.com/a/12957445\n        const max = Math.min(\n            typeof maxVal === \"number\" ? maxVal : JAVAMAXINT,\n            JAVAMAXINT\n        );\n        const min = Math.max(\n            typeof minVal === \"number\" ? minVal : JAVAMININT,\n            JAVAMININT\n        );\n        if (result.data > max) {\n            helper.addErrors(\n                INTEGEREXCEPTIONS.TOOBIG.create(\n                    start,\n                    reader.cursor,\n                    max.toString(),\n                    result.data.toString()\n                )\n            );\n        }\n        if (result.data < min) {\n            helper.addErrors(\n                INTEGEREXCEPTIONS.TOOSMALL.create(\n                    start,\n                    reader.cursor,\n                    min.toString(),\n                    result.data.toString()\n                )\n            );\n        }\n        return helper.succeed();\n    }\n};\n","import { CommandErrorBuilder } from \"../../brigadier/errors\";\nimport { ReturnHelper } from \"../../misc-functions\";\nimport { Parser } from \"../../types\";\n\nconst JAVAMINFLOAT = -2139095039;\nconst JAVAMAXFLOAT = 2139095039;\n\nconst FLOATEXCEPTIONS = {\n    TOOBIG: new CommandErrorBuilder(\n        \"argument.float.big\",\n        \"Float must not be more than %s, found %s\"\n    ),\n    TOOSMALL: new CommandErrorBuilder(\n        \"argument.float.low\",\n        \"Float must not be less than %s, found %s\"\n    )\n};\n\nexport const floatParser: Parser = {\n    parse: (reader, properties) => {\n        const helper = new ReturnHelper(properties);\n        const start = reader.cursor;\n        const result = reader.readFloat();\n        if (!helper.merge(result)) {\n            return helper.fail();\n        }\n        const maxVal = properties.node_properties.max;\n        const minVal = properties.node_properties.min;\n        // See https://stackoverflow.com/a/12957445\n        const max = Math.min(\n            typeof maxVal === \"number\" ? maxVal : JAVAMAXFLOAT,\n            JAVAMAXFLOAT\n        );\n        const min = Math.max(\n            typeof minVal === \"number\" ? minVal : JAVAMINFLOAT,\n            JAVAMINFLOAT\n        );\n        if (result.data > max) {\n            helper.addErrors(\n                FLOATEXCEPTIONS.TOOBIG.create(\n                    start,\n                    reader.cursor,\n                    max.toString(),\n                    result.data.toString()\n                )\n            );\n        }\n        if (result.data < min) {\n            helper.addErrors(\n                FLOATEXCEPTIONS.TOOSMALL.create(\n                    start,\n                    reader.cursor,\n                    min.toString(),\n                    result.data.toString()\n                )\n            );\n        }\n        return helper.succeed();\n    }\n};\n","export * from \"./bool\";\nexport * from \"./string\";\nexport * from \"./integer\";\nexport * from \"./float\";\n","import { CompletionItemKind } from \"vscode-languageserver/lib/main\";\nimport { ReturnHelper } from \"../misc-functions\";\nimport { Parser } from \"../types\";\n\nexport const literalParser: Parser = {\n    kind: CompletionItemKind.Method,\n    parse: (reader, properties) => {\n        const helper = new ReturnHelper(properties);\n        const begin = reader.cursor;\n        const literal = properties.path[properties.path.length - 1];\n        if (\n            properties.suggesting &&\n            literal.startsWith(reader.getRemaining())\n        ) {\n            helper.addSuggestions(literal);\n        }\n        if (reader.canRead(literal.length)) {\n            const end = begin + literal.length;\n            if (reader.string.substring(begin, end) === literal) {\n                reader.cursor = end;\n                if (reader.peek() === \" \" || !reader.canRead()) {\n                    return helper.succeed();\n                }\n            }\n        }\n        return helper.fail();\n    }\n};\n","import {\n    CompletionItemKind,\n    DiagnosticSeverity\n} from \"vscode-languageserver/lib/main\";\n\nimport { CommandErrorBuilder } from \"../../brigadier/errors\";\nimport { StringReader } from \"../../brigadier/string-reader\";\nimport {\n    BlocksPropertyInfo,\n    NamespacedName,\n    SingleBlockPropertyInfo\n} from \"../../data/types\";\nimport {\n    namespaceSuggestionString,\n    ReturnHelper,\n    stringifyNamespace\n} from \"../../misc-functions\";\nimport {\n    buildTagActions,\n    parseNamespaceOrTag\n} from \"../../misc-functions/parsing/nmsp-tag\";\nimport { Parser, ParserInfo, ReturnedInfo, Suggestion } from \"../../types\";\n\nexport const predicateParser: Parser = {\n    parse: (reader, info) => parseBlockArgument(reader, info, true)\n};\n\nexport const stateParser: Parser = {\n    parse: (reader, info) => parseBlockArgument(reader, info, false)\n};\n\ninterface PropertyExceptions {\n    duplicate: CommandErrorBuilder;\n    invalid: CommandErrorBuilder;\n    novalue: CommandErrorBuilder;\n    unknown: CommandErrorBuilder;\n}\n\nconst exceptions = {\n    block_properties: {\n        duplicate: new CommandErrorBuilder(\n            \"argument.block.property.duplicate\",\n            \"Property '%s' can only be set once for block %s\"\n        ),\n        invalid: new CommandErrorBuilder(\n            \"argument.block.property.invalid\",\n            \"Block %s does not accept '%s' for %s property\"\n        ),\n        novalue: new CommandErrorBuilder(\n            \"argument.block.property.novalue\",\n            \"Expected value for property '%s' on block %s\"\n        ),\n        unknown: new CommandErrorBuilder(\n            \"argument.block.property.unknown\",\n            \"Block %s does not have property '%s'\"\n        )\n    },\n    invalid_block: new CommandErrorBuilder(\n        \"argument.block.id.invalid\",\n        \"Unknown block type '%s'\"\n    ),\n    no_tags: new CommandErrorBuilder(\n        \"argument.block.tag.disallowed\",\n        \"Tags aren't allowed here, only actual blocks\"\n    ),\n    tag_properties: {\n        duplicate: new CommandErrorBuilder(\n            \"argument.block_tag.property.duplicate\",\n            \"Property '%s' can only be set once for block tag %s\"\n        ),\n        invalid: new CommandErrorBuilder(\n            \"argument.block_tag.property.invalid\",\n            \"Block tag %s does not accept '%s' for %s property\"\n        ),\n        novalue: new CommandErrorBuilder(\n            \"argument.block_tag.property.novalue\",\n            \"Expected value for property '%s' on block tag %s\"\n        ),\n        unknown: new CommandErrorBuilder(\n            \"argument.block_tag.property.unknown\",\n            \"Block tag %s does not have property '%s'\"\n        )\n    },\n    unknown_properties: {\n        duplicate: new CommandErrorBuilder(\n            \"argument.unknown_block_tag.property.duplicate\",\n            \"Property '%s' can only be set once for unknown block tag %s\"\n        ),\n        invalid: new CommandErrorBuilder(\n            \"argument.unknown_block_tag.property.invalid\",\n            \"Unknown block tag %s might not accept '%s' for %s property\",\n            DiagnosticSeverity.Warning\n        ),\n        novalue: new CommandErrorBuilder(\n            \"argument.unknown_block_tag.property.novalue\",\n            \"Expected value for property '%s' on unknown block tag %s\"\n        ),\n        unknown: new CommandErrorBuilder(\n            \"argument.unknown_block_tag.property.unknown\",\n            \"Unknown block tag %s might not have property '%s'\",\n            DiagnosticSeverity.Warning\n        )\n    },\n\n    unclosed_props: new CommandErrorBuilder(\n        \"argument.block.property.unclosed\",\n        \"Expected closing ] for block state properties\"\n    ),\n\n    unknown_tag: new CommandErrorBuilder(\n        \"arguments.block.tag.unknown\", // Argument_s_ [sic]\n        \"Unknown block tag '%s'\"\n    )\n};\n\nexport function parseBlockArgument(\n    reader: StringReader,\n    info: ParserInfo,\n    tags: boolean\n): ReturnedInfo<undefined> {\n    const helper = new ReturnHelper(info);\n    const start = reader.cursor;\n    const tagHandling = tags ? \"block_tags\" : exceptions.no_tags;\n    const parsed = parseNamespaceOrTag(reader, info, tagHandling);\n    let stringifiedName: string | undefined;\n    if (helper.merge(parsed)) {\n        const parsedResult = parsed.data;\n        if (parsedResult.resolved && parsedResult.values) {\n            stringifiedName = `#${stringifyNamespace(parsedResult.parsed)}`;\n            helper.merge(\n                buildTagActions(\n                    parsedResult.values,\n                    start + 1,\n                    reader.cursor,\n                    \"block_tags\",\n                    info.data.localData\n                )\n            );\n            const props = constructProperties(\n                parsedResult.resolved,\n                info.data.globalData.blocks\n            );\n            const propsResult = parseProperties(\n                reader,\n                props || {},\n                exceptions.tag_properties,\n                stringifiedName\n            );\n            if (!helper.merge(propsResult)) {\n                return helper.fail();\n            }\n        } else {\n            stringifiedName = stringifyNamespace(parsed.data.parsed);\n            if (info.suggesting && !reader.canRead()) {\n                helper.addSuggestions(\n                    ...namespaceSuggestionString(\n                        Object.keys(info.data.globalData.blocks),\n                        parsed.data.parsed,\n                        start\n                    )\n                );\n            }\n            const props = info.data.globalData.blocks[stringifiedName];\n            if (!props) {\n                helper.addErrors(\n                    exceptions.invalid_block.create(start, reader.cursor)\n                );\n            }\n            const result = parseProperties(\n                reader,\n                props || {},\n                exceptions.block_properties,\n                stringifiedName\n            );\n            if (!helper.merge(result)) {\n                return helper.fail();\n            }\n        }\n    } else {\n        if (parsed.data) {\n            helper.addErrors(\n                exceptions.unknown_tag.create(\n                    start,\n                    reader.cursor,\n                    stringifyNamespace(parsed.data)\n                )\n            );\n            stringifiedName = `#${stringifyNamespace(parsed.data)}`;\n            const propsResult = parseProperties(\n                reader,\n                {},\n                exceptions.unknown_properties,\n                stringifiedName\n            );\n            if (!helper.merge(propsResult)) {\n                return helper.fail();\n            }\n        } else {\n            // Parsing of the namespace failed\n            return helper.fail();\n        }\n    }\n    return helper.succeed();\n}\n\n// Ugly call signature. Need to see how upstream handles tag properties.\n// At the moment, it is very broken\nfunction parseProperties(\n    reader: StringReader,\n    options: SingleBlockPropertyInfo,\n    errors: PropertyExceptions,\n    name: string\n): ReturnedInfo<Map<string, string>> {\n    const helper = new ReturnHelper();\n    const result = new Map<string, string>();\n    if (reader.peek() === \"[\") {\n        const start = reader.cursor;\n        reader.skip();\n        const props = Object.keys(options);\n        reader.skipWhitespace();\n        while (reader.canRead() && reader.peek() !== \"]\") {\n            reader.skipWhitespace();\n            const propStart = reader.cursor;\n            const propParse = reader.readOption(\n                props,\n                false,\n                CompletionItemKind.Property\n            );\n            const propKey = propParse.data;\n            const propSuccessful = helper.merge(propParse);\n            if (propKey === false) {\n                // Strange order allows better type checker reasoning\n                // Parsing failed\n                return helper.fail();\n            }\n            if (!propSuccessful) {\n                helper.addErrors(\n                    errors.unknown.create(\n                        propStart,\n                        reader.cursor,\n                        name,\n                        propKey\n                    )\n                );\n            }\n            if (result.has(propKey)) {\n                helper.addErrors(\n                    errors.duplicate.create(\n                        propStart,\n                        reader.cursor,\n                        propKey,\n                        name\n                    )\n                );\n            }\n            reader.skipWhitespace();\n            if (!reader.canRead() || reader.peek() !== \"=\") {\n                return helper.fail(\n                    errors.novalue.create(\n                        propStart,\n                        reader.cursor,\n                        propKey,\n                        name\n                    )\n                );\n            }\n            reader.skip();\n            reader.skipWhitespace();\n            const valueStart = reader.cursor;\n            const valueParse = reader.readOption(\n                options[propKey] || [],\n                false,\n                CompletionItemKind.EnumMember\n            );\n            const valueSuccessful = helper.merge(valueParse);\n            const value = valueParse.data;\n            if (value === false) {\n                return helper.fail();\n            }\n            const error = errors.invalid.create(\n                valueStart,\n                reader.cursor,\n                name,\n                value,\n                propKey\n            );\n            const adderrorIf = (b: boolean) =>\n                b && propSuccessful && !valueSuccessful\n                    ? helper.addErrors(error)\n                    : undefined;\n            adderrorIf(value.length > 0);\n            result.set(propKey, value);\n            reader.skipWhitespace();\n            if (reader.canRead()) {\n                if (reader.peek() === \",\") {\n                    adderrorIf(value.length === 0);\n                    reader.skip();\n                    continue;\n                }\n                if (reader.peek() === \"]\") {\n                    adderrorIf(value.length === 0);\n                    break;\n                }\n            }\n            return helper.fail(\n                exceptions.unclosed_props.create(start, reader.cursor)\n            );\n        }\n        if (!reader.canRead()) {\n            helper.addSuggestions(\n                ...props.map<Suggestion>(prop => ({\n                    kind: CompletionItemKind.Property,\n                    start: reader.cursor,\n                    text: prop\n                }))\n            );\n            return helper.fail(\n                exceptions.unclosed_props.create(start, reader.cursor)\n            );\n        }\n        reader.expect(\"]\"); // Sanity check\n    }\n    return helper.succeed(result);\n}\n\nfunction constructProperties(\n    options: NamespacedName[],\n    blocks: BlocksPropertyInfo\n): SingleBlockPropertyInfo {\n    const result: SingleBlockPropertyInfo = {};\n    for (const blockName of options) {\n        const stringified = stringifyNamespace(blockName);\n        const block = blocks[stringified];\n        if (block) {\n            for (const prop in block) {\n                if (block.hasOwnProperty(prop)) {\n                    result[prop] = Array.from(\n                        new Set((result[prop] || []).concat(block[prop]))\n                    );\n                }\n            }\n        }\n    }\n    return result;\n}\n","import { CommandErrorBuilder } from \"../../brigadier/errors\";\nimport { StringReader } from \"../../brigadier/string-reader\";\nimport { ReturnHelper } from \"../../misc-functions\";\nimport { Parser, ParserInfo, ReturnedInfo } from \"../../types\";\n\nconst MIXED = new CommandErrorBuilder(\n    \"argument.pos.mixed\",\n    \"Cannot mix world & local coordinates (everything must either use ^ or not)\"\n);\n\nconst INCOMPLETE = new CommandErrorBuilder(\n    \"argument.pos.incomplete\",\n    \"Incomplete position argument. Only %s coords are present, when %s should be\"\n);\n\nconst NO_LOCAL = new CommandErrorBuilder(\n    \"argument.pos.nolocal\",\n    \"Local coords are not allowed\"\n);\n\nconst LOCAL = \"^\";\nconst RELATIVE = \"~\";\n\nexport interface CoordRules {\n    count: 2 | 3;\n    float: boolean;\n    local: boolean;\n}\n\nconst fail = (\n    reader: StringReader,\n    helper: ReturnHelper,\n    count: number,\n    hasWorld: boolean,\n    hasLocal: boolean,\n    start: number,\n    i: number\n) => {\n    if (!hasWorld) {\n        helper.addSuggestions({\n            start: reader.cursor,\n            text: LOCAL\n        });\n    }\n    if (!hasLocal) {\n        helper.addSuggestions({\n            start: reader.cursor,\n            text: RELATIVE\n        });\n    }\n    return helper.fail(\n        INCOMPLETE.create(\n            start,\n            reader.cursor,\n            (i + 1).toString(),\n            count.toString()\n        )\n    );\n};\n\nexport class CoordParser implements Parser {\n    private readonly rules: CoordRules;\n\n    public constructor(rules: CoordRules) {\n        this.rules = rules;\n    }\n\n    public parse(\n        reader: StringReader,\n        info: ParserInfo\n    ): ReturnedInfo<undefined> {\n        const helper = new ReturnHelper(info);\n        let hasLocal = false;\n        let hasWorld = false;\n        const start = reader.cursor;\n        for (let i = 0; i < this.rules.count; i++) {\n            if (!reader.canRead()) {\n                return fail(\n                    reader,\n                    helper,\n                    this.rules.count,\n                    hasWorld,\n                    hasLocal,\n                    start,\n                    0\n                );\n            }\n\n            const cstart = reader.cursor;\n            switch (reader.peek()) {\n                case RELATIVE:\n                    hasWorld = true;\n                    reader.skip();\n                    if (!helper.merge(this.parseNumber(reader))) {\n                        return helper.fail();\n                    }\n                    if (hasLocal) {\n                        helper.addErrors(MIXED.create(cstart, reader.cursor));\n                    }\n                    break;\n                case LOCAL:\n                    if (!this.rules.local) {\n                        helper.addErrors(\n                            NO_LOCAL.create(reader.cursor, reader.cursor + 1)\n                        );\n                    }\n                    hasLocal = true;\n                    reader.skip();\n                    if (!helper.merge(this.parseNumber(reader))) {\n                        return helper.fail();\n                    }\n                    if (hasWorld) {\n                        helper.addErrors(MIXED.create(cstart, reader.cursor));\n                    }\n                    break;\n                default:\n                    hasWorld = true;\n                    if (!helper.merge(this.parseNumber(reader, false))) {\n                        return helper.fail();\n                    }\n                    if (hasLocal) {\n                        helper.addErrors(MIXED.create(cstart, reader.cursor));\n                    }\n            }\n\n            if (\n                i < this.rules.count - 1 &&\n                (!reader.canRead() || !helper.merge(reader.expect(\" \")))\n            ) {\n                return fail(\n                    reader,\n                    helper,\n                    this.rules.count,\n                    hasWorld,\n                    hasLocal,\n                    start,\n                    i\n                );\n            }\n        }\n        return helper.succeed();\n    }\n\n    private parseNumber(\n        reader: StringReader,\n        allowBlank: boolean = true\n    ): ReturnedInfo<number> {\n        if ((!reader.canRead() || reader.peek().match(/\\s/)) && allowBlank) {\n            return new ReturnHelper().succeed(0);\n        }\n        return this.rules.float ? reader.readFloat() : reader.readInt();\n    }\n}\n\nexport const rotation = new CoordParser({\n    count: 2,\n    float: true,\n    local: false\n});\n\nexport const vec2 = new CoordParser({\n    count: 2,\n    float: true,\n    local: true\n});\n\nexport const vec3 = new CoordParser({\n    count: 3,\n    float: true,\n    local: true\n});\n\nexport const blockPos = new CoordParser({\n    count: 3,\n    float: false,\n    local: true\n});\n","import { CommandErrorBuilder } from \"../../brigadier/errors\";\nimport { StringReader } from \"../../brigadier/string-reader\";\nimport {\n    buildTagActions,\n    namespaceSuggestionString,\n    parseNamespaceOrTag,\n    ReturnHelper,\n    stringifyNamespace\n} from \"../../misc-functions\";\nimport { Parser, ParserInfo, ReturnedInfo } from \"../../types\";\n\nconst NOTAG = new CommandErrorBuilder(\n    \"argument.item.tag.disallowed\",\n    \"Tags aren't allowed here, only actual items\"\n);\n\nconst UNKNOWNTAG = new CommandErrorBuilder(\n    \"arguments.item.tag.unknown\",\n    \"Unknown item tag '%s'\"\n);\n\nconst UNKNOWNITEM = new CommandErrorBuilder(\n    \"argument.item.id.invalid\",\n    \"Unknown item '%s'\"\n);\n\nexport class ItemParser implements Parser {\n    private readonly useTags: boolean;\n\n    public constructor(useTags: boolean) {\n        this.useTags = useTags;\n    }\n\n    public parse(\n        reader: StringReader,\n        properties: ParserInfo\n    ): ReturnedInfo<undefined> {\n        const helper = new ReturnHelper(properties);\n        const start = reader.cursor;\n        const parsed = parseNamespaceOrTag(\n            reader,\n            properties,\n            this.useTags ? \"item_tags\" : NOTAG\n        );\n        if (helper.merge(parsed)) {\n            const items: string[] = [];\n            if (parsed.data.resolved && parsed.data.values) {\n                helper.merge(\n                    buildTagActions(\n                        parsed.data.values,\n                        start + 1,\n                        reader.cursor,\n                        \"item_tags\",\n                        properties.data.localData\n                    )\n                );\n                parsed.data.values.forEach(v => {\n                    items.push(...(v.data || { values: [] }).values);\n                });\n            } else {\n                if (properties.suggesting && !reader.canRead()) {\n                    helper.addSuggestions(\n                        ...namespaceSuggestionString(\n                            properties.data.globalData.items,\n                            parsed.data.parsed,\n                            start\n                        )\n                    );\n                }\n                const name = stringifyNamespace(parsed.data.parsed);\n                if (properties.data.globalData.items.indexOf(name) < 0) {\n                    helper.addErrors(\n                        UNKNOWNITEM.create(start, reader.cursor, name)\n                    );\n                }\n                items.push(name);\n            }\n        } else {\n            if (parsed.data) {\n                helper.addErrors(\n                    UNKNOWNTAG.create(\n                        start,\n                        reader.cursor,\n                        stringifyNamespace(parsed.data)\n                    )\n                );\n            } else {\n                return helper.fail();\n            }\n        }\n        return helper.succeed();\n    }\n}\n\nexport const stack = new ItemParser(false);\nexport const predicate = new ItemParser(true);\n","export const COLORS = [\n    \"black\",\n    \"dark_blue\",\n    \"dark_green\",\n    \"dark_aqua\",\n    \"dark_red\",\n    \"dark_purple\",\n    \"gold\",\n    \"gray\",\n    \"dark_gray\",\n    \"blue\",\n    \"green\",\n    \"aqua\",\n    \"red\",\n    \"light_purple\",\n    \"yellow\",\n    \"white\",\n    \"reset\"\n];\n","export const itemSlots = slotsBuilder();\n\nfunction slotsBuilder(): string[] {\n    const slots = [];\n\n    slots.push(\"armor.chest\", \"armor.feet\", \"armor.head\", \"armor.legs\");\n\n    for (let i = 0; i < 54; i++) {\n        slots.push(`container.${i}`);\n    }\n\n    for (let i = 0; i < 27; i++) {\n        slots.push(`enderchest.${i}`);\n    }\n\n    for (let i = 0; i < 25; i++) {\n        slots.push(`horse.${i}`);\n    }\n    slots.push(\"horse.armor\", \"horse.chest\", \"horse.saddle\");\n\n    for (let i = 0; i < 9; i++) {\n        slots.push(`hotbar.${i}`);\n    }\n\n    for (let i = 0; i < 27; i++) {\n        slots.push(`inventory.${i}`);\n    }\n\n    for (let i = 0; i < 8; i++) {\n        slots.push(`villager.${i}`);\n    }\n\n    slots.push(\"weapon\", \"weapon.mainhand\", \"weapon.offhand\");\n    return slots;\n}\n","import { COLORS } from \"../../colors\";\n\nexport const scoreboardSlots = createSlots();\n\nfunction createSlots(): string[] {\n    const slots = [];\n\n    slots.push(\"list\", \"sidebar\", \"belowName\");\n\n    for (const s of COLORS) {\n        slots.push(`sidebar.team.${s}`);\n    }\n    return slots;\n}\n","import { COLORS } from \"../../colors\";\n\nexport const anchors = [\"feet\", \"eyes\"];\nexport const operations = [\"+=\", \"-=\", \"*=\", \"/=\", \"%=\", \"=\", \">\", \"<\", \"><\"];\nexport const colors = COLORS;\n\nexport const effects = [\n    \"minecraft:speed\",\n    \"minecraft:slowness\",\n    \"minecraft:haste\",\n    \"minecraft:mining_fatigue\",\n    \"minecraft:strength\",\n    \"minecraft:instant_health\",\n    \"minecraft:instant_damage\",\n    \"minecraft:jump_boost\",\n    \"minecraft:nausea\",\n    \"minecraft:regeneration\",\n    \"minecraft:resistance\",\n    \"minecraft:fire_resistance\",\n    \"minecraft:water_breathing\",\n    \"minecraft:invisibility\",\n    \"minecraft:blindness\",\n    \"minecraft:night_vision\",\n    \"minecraft:hunger\",\n    \"minecraft:weakness\",\n    \"minecraft:poison\",\n    \"minecraft:wither\",\n    \"minecraft:health_boost\",\n    \"minecraft:absorption\",\n    \"minecraft:saturation\",\n    \"minecraft:glowing\",\n    \"minecraft:levitation\",\n    \"minecraft:luck\",\n    \"minecraft:unluck\",\n    \"minecraft:slow_falling\",\n    \"minecraft:conduit_power\",\n    \"minecraft:dolphins_grace\"\n];\n\nexport const enchantments = [\n    \"minecraft:protection\",\n    \"minecraft:fire_protection\",\n    \"minecraft:feather_falling\",\n    \"minecraft:blast_protection\",\n    \"minecraft:projectile_protection\",\n    \"minecraft:respiration\",\n    \"minecraft:aqua_affinity\",\n    \"minecraft:thorns\",\n    \"minecraft:depth_strider\",\n    \"minecraft:frost_walker\",\n    \"minecraft:binding_curse\",\n    \"minecraft:sharpness\",\n    \"minecraft:smite\",\n    \"minecraft:bane_of_arthropods\",\n    \"minecraft:knockback\",\n    \"minecraft:fire_aspect\",\n    \"minecraft:looting\",\n    \"minecraft:sweeping\",\n    \"minecraft:efficiency\",\n    \"minecraft:silk_touch\",\n    \"minecraft:unbreaking\",\n    \"minecraft:fortune\",\n    \"minecraft:power\",\n    \"minecraft:punch\",\n    \"minecraft:flame\",\n    \"minecraft:infinity\",\n    \"minecraft:luck_of_the_sea\",\n    \"minecraft:lure\",\n    \"minecraft:loyalty\",\n    \"minecraft:impaling\",\n    \"minecraft:riptide\",\n    \"minecraft:channeling\",\n    \"minecraft:mending\",\n    \"minecraft:vanishing_curse\"\n];\n\nexport const particles = [\n    \"minecraft:ambient_entity_effect\",\n    \"minecraft:angry_villager\",\n    \"minecraft:barrier\",\n    \"minecraft:block\",\n    \"minecraft:bubble\",\n    \"minecraft:cloud\",\n    \"minecraft:crit\",\n    \"minecraft:damage_indicator\",\n    \"minecraft:dragon_breath\",\n    \"minecraft:dripping_lava\",\n    \"minecraft:dripping_water\",\n    \"minecraft:dust\",\n    \"minecraft:effect\",\n    \"minecraft:elder_guardian\",\n    \"minecraft:enchanted_hit\",\n    \"minecraft:enchant\",\n    \"minecraft:end_rod\",\n    \"minecraft:entity_effect\",\n    \"minecraft:explosion_emitter\",\n    \"minecraft:explosion\",\n    \"minecraft:falling_dust\",\n    \"minecraft:firework\",\n    \"minecraft:fishing\",\n    \"minecraft:flame\",\n    \"minecraft:happy_villager\",\n    \"minecraft:heart\",\n    \"minecraft:instant_effect\",\n    \"minecraft:item\",\n    \"minecraft:item_slime\",\n    \"minecraft:item_snowball\",\n    \"minecraft:large_smoke\",\n    \"minecraft:lava\",\n    \"minecraft:mycelium\",\n    \"minecraft:note\",\n    \"minecraft:poof\",\n    \"minecraft:portal\",\n    \"minecraft:rain\",\n    \"minecraft:smoke\",\n    \"minecraft:spit\",\n    \"minecraft:squid_ink\",\n    \"minecraft:sweep_attack\",\n    \"minecraft:totem_of_undying\",\n    \"minecraft:underwater\",\n    \"minecraft:splash\",\n    \"minecraft:witch\",\n    \"minecraft:bubble_pop\",\n    \"minecraft:current_down\",\n    \"minecraft:bubble_column_up\",\n    \"minecraft:nautilus\"\n];\n\nexport const entities = [\n    \"area_effect_cloud\",\n    \"armor_stand\",\n    \"arrow\",\n    \"bat\",\n    \"blaze\",\n    \"boat\",\n    \"cave_spider\",\n    \"chicken\",\n    \"cod\",\n    \"cow\",\n    \"creeper\",\n    \"donkey\",\n    \"dolphin\",\n    \"dragon_fireball\",\n    \"drowned\",\n    \"elder_guardian\",\n    \"end_crystal\",\n    \"ender_dragon\",\n    \"enderman\",\n    \"endermite\",\n    \"evoker_fangs\",\n    \"evoker\",\n    \"experience_orb\",\n    \"eye_of_ender\",\n    \"falling_block\",\n    \"firework_rocket\",\n    \"ghast\",\n    \"giant\",\n    \"guardian\",\n    \"horse\",\n    \"husk\",\n    \"illusioner\",\n    \"item\",\n    \"item_frame\",\n    \"fireball\",\n    \"leash_knot\",\n    \"llama\",\n    \"llama_spit\",\n    \"magma_cube\",\n    \"minecart\",\n    \"chest_minecart\",\n    \"command_block_minecart\",\n    \"furnace_minecart\",\n    \"hopper_minecart\",\n    \"spawner_minecart\",\n    \"tnt_minecart\",\n    \"mule\",\n    \"mooshroom\",\n    \"ocelot\",\n    \"painting\",\n    \"parrot\",\n    \"pig\",\n    \"pufferfish\",\n    \"zombie_pigman\",\n    \"polar_bear\",\n    \"tnt\",\n    \"rabbit\",\n    \"salmon\",\n    \"sheep\",\n    \"shulker\",\n    \"shulker_bullet\",\n    \"silverfish\",\n    \"skeleton\",\n    \"skeleton_horse\",\n    \"slime\",\n    \"small_fireball\",\n    \"snow_golem\",\n    \"snowball\",\n    \"spectral_arrow\",\n    \"spider\",\n    \"squid\",\n    \"stray\",\n    \"tropical_fish\",\n    \"turtle\",\n    \"egg\",\n    \"ender_pearl\",\n    \"experience_bottle\",\n    \"potion\",\n    \"vex\",\n    \"villager\",\n    \"iron_golem\",\n    \"vindicator\",\n    \"witch\",\n    \"wither\",\n    \"wither_skeleton\",\n    \"wither_skull\",\n    \"wolf\",\n    \"zombie\",\n    \"zombie_horse\",\n    \"zombie_villager\",\n    \"phantom\",\n    \"lightning_bolt\",\n    \"trident\"\n];\n\nexport const dimensions = [\"overworld\", \"the_nether\", \"the_end\"];\n","import { CompletionItemKind } from \"vscode-languageserver\";\nimport { CommandErrorBuilder } from \"../../brigadier/errors\";\nimport { StringReader } from \"../../brigadier/string-reader\";\nimport { COLORS } from \"../../colors\";\nimport { itemSlots } from \"../../data/lists/item-slot\";\nimport { scoreboardSlots } from \"../../data/lists/scoreboard-slot\";\nimport { anchors, operations } from \"../../data/lists/statics\";\nimport { ReturnHelper } from \"../../misc-functions\";\nimport { Parser, ParserInfo, ReturnedInfo } from \"../../types\";\n\nexport class ListParser implements Parser {\n    private readonly error: CommandErrorBuilder;\n    private readonly options: string[];\n\n    public constructor(options: string[], err: CommandErrorBuilder) {\n        this.options = options;\n        this.error = err;\n    }\n\n    public parse(\n        reader: StringReader,\n        info: ParserInfo\n    ): ReturnedInfo<undefined> {\n        const start = reader.cursor;\n        const helper = new ReturnHelper(info);\n        const optResult = reader.readOption(\n            this.options,\n            false,\n            CompletionItemKind.EnumMember,\n            \"no\"\n        );\n        if (helper.merge(optResult)) {\n            return helper.succeed();\n        } else {\n            return helper.fail(\n                this.error.create(\n                    start,\n                    reader.cursor,\n                    optResult.data.toString()\n                )\n            );\n        }\n    }\n}\n\nconst colorError = new CommandErrorBuilder(\n    \"argument.color.invalid\",\n    \"Unknown color '%s'\"\n);\nexport const colorParser = new ListParser(COLORS, colorError);\n\nconst entityAnchorError = new CommandErrorBuilder(\n    \"argument.anchor.invalid\",\n    \"Invalid entity anchor position %s\"\n);\nexport const entityAnchorParser = new ListParser(anchors, entityAnchorError);\n\nconst slotError = new CommandErrorBuilder(\"slot.unknown\", \"Unknown slot '%s'\");\nexport const itemSlotParser = new ListParser(itemSlots, slotError);\n\nconst operationError = new CommandErrorBuilder(\n    \"arguments.operation.invalid\",\n    \"Invalid operation\"\n);\nexport const operationParser = new ListParser(operations, operationError);\n\nconst scoreboardSlotError = new CommandErrorBuilder(\n    \"argument.scoreboardDisplaySlot.invalid\",\n    \"Unknown display slot '%s'\"\n);\nexport const scoreBoardSlotParser = new ListParser(\n    scoreboardSlots,\n    scoreboardSlotError\n);\n","import { StringReader } from \"../../brigadier/string-reader\";\nimport { ReturnHelper } from \"../../misc-functions\";\nimport { Parser } from \"../../types\";\n\nexport const messageParser: Parser = {\n    parse: (reader: StringReader) => {\n        reader.cursor = reader.getTotalLength();\n        return new ReturnHelper().succeed();\n    }\n};\n","import { CommandErrorBuilder } from \"../../brigadier/errors\";\nimport { StringReader } from \"../../brigadier/string-reader\";\nimport {\n    dimensions,\n    effects,\n    enchantments,\n    entities,\n    particles\n} from \"../../data/lists/statics\";\nimport {\n    convertToNamespace,\n    parseNamespaceOption,\n    ReturnHelper,\n    stringifyNamespace\n} from \"../../misc-functions\";\nimport { ContextChange, Parser, ParserInfo, ReturnedInfo } from \"../../types\";\n\nexport class NamespaceListParser implements Parser {\n    private readonly error: CommandErrorBuilder;\n    private readonly options: string[];\n    public constructor(options: string[], errorBuilder: CommandErrorBuilder) {\n        this.options = options;\n        this.error = errorBuilder;\n    }\n    public parse(\n        reader: StringReader,\n        info: ParserInfo\n    ): ReturnedInfo<ContextChange> {\n        const helper = new ReturnHelper(info);\n        const start = reader.cursor;\n        const result = parseNamespaceOption(\n            reader,\n            this.options.map((v, _) => convertToNamespace(v))\n        );\n        if (helper.merge(result)) {\n            return helper.succeed();\n        } else {\n            if (result.data) {\n                return helper\n                    .addErrors(\n                        this.error.create(\n                            start,\n                            reader.cursor,\n                            stringifyNamespace(result.data)\n                        )\n                    )\n                    .succeed();\n            } else {\n                return helper.fail();\n            }\n        }\n    }\n}\n\nconst summonError = new CommandErrorBuilder(\n    \"entity.notFound\",\n    \"Unknown entity: %s\"\n);\nexport const summonParser = new NamespaceListParser(entities, summonError);\n\nconst enchantmentError = new CommandErrorBuilder(\n    \"enchantment.unknown\",\n    \"Unknown enchantment: %s\"\n);\nexport const enchantmentParser = new NamespaceListParser(\n    enchantments,\n    enchantmentError\n);\n\nconst mobEffectError = new CommandErrorBuilder(\n    \"effect.effectNotFound\",\n    \"Unknown effect: %s\"\n);\nexport const mobEffectParser = new NamespaceListParser(effects, mobEffectError);\n\nconst particleError = new CommandErrorBuilder(\n    \"particle.notFound\",\n    \"Unknown particle: %s\"\n);\nexport const particleParser = new NamespaceListParser(particles, particleError);\n\nconst dimensionError = new CommandErrorBuilder(\n    \"argument.dimension.invalid\",\n    \"Unknown dimension: '%s'\"\n);\n\nexport const dimensionParser = new NamespaceListParser(\n    dimensions,\n    dimensionError\n);\n","import { CompletionItemKind } from \"vscode-languageserver\";\nimport { CommandErrorBuilder } from \"../../brigadier/errors\";\nimport { Resources } from \"../../data/types\";\nimport {\n    buildTagActions,\n    ContextPath,\n    convertToNamespace,\n    getResourcesofType,\n    parseNamespace,\n    parseNamespaceOption,\n    parseNamespaceOrTag,\n    processParsedNamespaceOption,\n    ReturnHelper,\n    startPaths,\n    stringifyNamespace\n} from \"../../misc-functions\";\nimport { Parser } from \"../../types\";\n\nconst exceptions = {\n    advancement_notfound: new CommandErrorBuilder(\n        \"advancement.advancementNotFound\",\n        \"Unknown advancement: %s\"\n    ),\n    nobossbar: new CommandErrorBuilder(\n        \"commands.bossbar.unknown\",\n        \"No bossbar exists with the ID '%s'\"\n    ),\n    recipe_notfound: new CommandErrorBuilder(\n        \"recipe.notFound\",\n        \"Unkown recipe: %s\"\n    ),\n    unknown_function: new CommandErrorBuilder(\n        \"arguments.function.unknown\",\n        \"Unknown function '%s'\"\n    ),\n    unknown_resource: new CommandErrorBuilder(\n        \"argument.id.unknown\",\n        \"Unknown resource '%s'\"\n    ),\n    unknown_tag: new CommandErrorBuilder(\n        \"arguments.function.tag.unknown\",\n        \"Unknown function tag '#%s'\"\n    )\n};\n\nexport const functionParser: Parser = {\n    parse: (reader, info) => {\n        const helper = new ReturnHelper(info);\n        const start = reader.cursor;\n        const parsed = parseNamespaceOrTag(reader, info, \"function_tags\");\n        if (helper.merge(parsed)) {\n            const data = parsed.data;\n            if (data.resolved && data.values) {\n                helper.merge(\n                    buildTagActions(\n                        data.values,\n                        start,\n                        reader.cursor,\n                        \"item_tags\",\n                        info.data.localData\n                    )\n                );\n                return helper.succeed();\n            } else {\n                const options = getResourcesofType(info.data, \"functions\");\n                const postProcess = processParsedNamespaceOption(\n                    data.parsed,\n                    options,\n                    info.suggesting && !reader.canRead(),\n                    start,\n                    CompletionItemKind.Method\n                );\n                if (postProcess.data.length === 0) {\n                    helper.addErrors(\n                        exceptions.unknown_function.create(\n                            start,\n                            reader.cursor,\n                            stringifyNamespace(data.parsed)\n                        )\n                    );\n                }\n                return helper.mergeChain(postProcess).succeed();\n            }\n        } else {\n            if (!parsed.data) {\n                return helper.fail();\n            } else {\n                return helper\n                    .addErrors(\n                        exceptions.unknown_tag.create(\n                            start,\n                            reader.cursor,\n                            stringifyNamespace(parsed.data)\n                        )\n                    )\n                    .succeed();\n            }\n        }\n    }\n};\n\nconst idParser: Parser = {\n    parse: parseNamespace\n};\n\nconst bossbarParser: Parser = {\n    parse: (reader, info) => {\n        const helper = new ReturnHelper(info);\n        if (info.data.localData && info.data.localData.nbt.level) {\n            const start = reader.cursor;\n            const bars = info.data.localData.nbt.level.Data.CustomBossEvents;\n            const options = Object.keys(bars).map((v, _) =>\n                convertToNamespace(v)\n            );\n            const result = parseNamespaceOption(reader, options);\n            if (helper.merge(result)) {\n                return helper.succeed();\n            } else {\n                if (result.data) {\n                    return helper\n                        .addErrors(\n                            exceptions.nobossbar.create(\n                                start,\n                                reader.cursor,\n                                stringifyNamespace(result.data)\n                            )\n                        )\n                        .succeed();\n                } else {\n                    return helper.fail();\n                }\n            }\n        } else {\n            return helper.return(parseNamespace(reader));\n        }\n    }\n};\n\nconst resourceKinds: Array<\n    ContextPath<\n        | {\n              issue: CommandErrorBuilder;\n              resource: keyof Resources;\n          }\n        | { resource: Parser }\n    >\n> = [\n    {\n        data: {\n            issue: exceptions.advancement_notfound,\n            resource: \"advancements\"\n        },\n        path: [\"advancement\"]\n    },\n    { data: { resource: idParser }, path: [\"bossbar\", \"add\"] },\n    { data: { resource: bossbarParser }, path: [\"bossbar\"] },\n    {\n        data: { resource: bossbarParser },\n        path: [\"execute\", \"store\", \"result\"]\n    },\n    // Worrying about sounds is not in scope for initial release\n    { data: { resource: idParser }, path: [\"playsound\"] },\n    { data: { resource: idParser }, path: [\"stopsound\"] },\n    {\n        data: { resource: \"recipes\", issue: exceptions.advancement_notfound },\n        path: [\"recipe\"]\n    }\n];\n\nexport const resourceParser: Parser = {\n    parse: (reader, info) => {\n        const start = reader.cursor;\n        const helper = new ReturnHelper(info);\n        const kind = startPaths(resourceKinds, info.path);\n        if (kind) {\n            if (typeof kind.resource === \"object\") {\n                return helper.return(kind.resource.parse(reader, info));\n            } else {\n                const result = parseNamespaceOption(\n                    reader,\n                    getResourcesofType(info.data, kind.resource)\n                );\n                if (helper.merge(result)) {\n                    return helper.succeed();\n                } else {\n                    if (result.data) {\n                        return helper\n                            .addErrors(\n                                // @ts-ignore type inference failure\n                                (kind.issue as CommandErrorBuilder).create(\n                                    start,\n                                    reader.cursor,\n                                    stringifyNamespace(result.data)\n                                )\n                            )\n                            .succeed();\n                    } else {\n                        return helper.fail();\n                    }\n                }\n            }\n        } else {\n            throw new Error(\n                `Resource at path ${\n                    info.path\n                } does not have a supported resource`\n            );\n        }\n    }\n};\n","import { CommandErrorBuilder } from \"../../brigadier/errors\";\r\nimport { DisplaySlots } from \"../../data/nbt/nbt-types\";\r\nimport { ReturnHelper } from \"../../misc-functions\";\r\nimport { typed_keys } from \"../../misc-functions/third_party/typed-keys\";\r\nimport { Parser } from \"../../types\";\r\n\r\nconst exceptions = {\r\n    unknown_objective: new CommandErrorBuilder(\r\n        \"arguments.objective.notFound\",\r\n        \"Unknown scoreboard objective '%s'\"\r\n    ),\r\n    unknown_team: new CommandErrorBuilder(\"team.notFound\", \"Unknown team '%s'\")\r\n};\r\n\r\nconst slotPurposes: { [_ in keyof DisplaySlots]: string } = {\r\n    slot_0: \"list\",\r\n    slot_1: \"sidebar\",\r\n    slot_10: \"sidebar.team.gray\",\r\n    slot_11: \"sidebar.team.dark_gray\",\r\n    slot_12: \"sidebar.team.blue\",\r\n    slot_13: \"sidebar.team.green\",\r\n    slot_14: \"sidebar.team.aqua\",\r\n    slot_15: \"sidebar.team.red\",\r\n    slot_16: \"sidebar.team.light_purple\",\r\n    slot_17: \"sidebar.team.yellow\",\r\n    slot_18: \"sidebar.team.white\",\r\n    slot_2: \"belowName\",\r\n    slot_3: \"sidebar.team.black\",\r\n    slot_4: \"sidebar.team.dark_blue\",\r\n    slot_5: \"sidebar.team.dark_green\",\r\n    slot_6: \"sidebar.team.dark_aqua\",\r\n    slot_7: \"sidebar.team.dark_red\",\r\n    slot_8: \"sidebar.team.dark_purple\",\r\n    slot_9: \"sidebar.team.gold\"\r\n};\r\n\r\nexport const objectiveParser: Parser = {\r\n    parse: (reader, info) => {\r\n        const helper = new ReturnHelper(info);\r\n        const start = reader.cursor;\r\n        if (info.data.localData) {\r\n            const scoreboardData = info.data.localData.nbt.scoreboard;\r\n            if (scoreboardData) {\r\n                const options = scoreboardData.data.Objectives.map(v => v.Name);\r\n                const result = reader.readOption(\r\n                    options,\r\n                    false,\r\n                    undefined,\r\n                    \"no\"\r\n                );\r\n                if (helper.merge(result)) {\r\n                    if (!info.suggesting) {\r\n                        for (const objective of scoreboardData.data\r\n                            .Objectives) {\r\n                            if (objective.Name === result.data) {\r\n                                helper.addActions({\r\n                                    data: `${\r\n                                        objective.DisplayName\r\n                                    } - Criteria: ${objective.CriteriaName}`,\r\n                                    high: reader.cursor,\r\n                                    low: start,\r\n                                    type: \"hover\"\r\n                                });\r\n                                break;\r\n                            }\r\n                        }\r\n                        for (const slot of typed_keys(\r\n                            scoreboardData.data.DisplaySlots\r\n                        )) {\r\n                            if (slot === result.data) {\r\n                                helper.addActions({\r\n                                    data: `Displayed in ${slotPurposes[slot]}`,\r\n                                    high: reader.cursor,\r\n                                    low: start,\r\n                                    type: \"hover\"\r\n                                });\r\n                            }\r\n                        }\r\n                    }\r\n                } else {\r\n                    if (result.data) {\r\n                        helper.addErrors(\r\n                            exceptions.unknown_objective.create(\r\n                                start,\r\n                                reader.cursor,\r\n                                result.data\r\n                            )\r\n                        );\r\n                    } else {\r\n                        return helper.fail();\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return helper.succeed();\r\n    }\r\n};\r\n\r\nexport const teamParser: Parser = {\r\n    parse: (reader, info) => {\r\n        const helper = new ReturnHelper();\r\n        const start = reader.cursor;\r\n        if (info.data.localData) {\r\n            const scoreboardData = info.data.localData.nbt.scoreboard;\r\n            if (scoreboardData) {\r\n                const options = scoreboardData.data.Teams;\r\n                const result = reader.readOption(\r\n                    options.map(v => v.Name),\r\n                    false,\r\n                    undefined,\r\n                    \"no\"\r\n                );\r\n                if (helper.merge(result)) {\r\n                    for (const team of options) {\r\n                        if (team.Name === result.data) {\r\n                            helper.addActions({\r\n                                data: `\\`\\`\\`json\r\n${JSON.stringify(team, undefined, 4)}\r\n\\`\\`\\``,\r\n                                high: reader.cursor,\r\n                                low: start,\r\n                                type: \"hover\"\r\n                            });\r\n                            break;\r\n                        }\r\n                    }\r\n                } else {\r\n                    if (result.data) {\r\n                        helper.addErrors(\r\n                            exceptions.unknown_objective.create(\r\n                                start,\r\n                                reader.cursor,\r\n                                result.data\r\n                            )\r\n                        );\r\n                    } else {\r\n                        return helper.fail();\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return helper.succeed();\r\n    }\r\n};\r\nexport const criteriaParser = undefined;\r\n","import { CommandNode } from \"../data/types\";\nimport { Parser } from \"../types\";\n\nimport * as brigadierParsers from \"./brigadier\";\nimport { literalParser } from \"./literal\";\nimport * as blockParsers from \"./minecraft/block\";\nimport * as coordParsers from \"./minecraft/coordinates\";\nimport * as itemParsers from \"./minecraft/item\";\nimport * as listParsers from \"./minecraft/lists\";\nimport { messageParser } from \"./minecraft/message\";\nimport * as namespaceParsers from \"./minecraft/namespace-list\";\nimport { functionParser, resourceParser } from \"./minecraft/resources\";\nimport { objectiveParser, teamParser } from \"./minecraft/scoreboard\";\n\n/**\n * Incomplete:\n * https://github.com/Levertion/mcfunction-langserver/projects/1\n */\nconst implementedParsers: { [id: string]: Parser } = {\n    \"brigadier:bool\": brigadierParsers.boolParser,\n    \"brigadier:float\": brigadierParsers.floatParser,\n    \"brigadier:integer\": brigadierParsers.intParser,\n    \"brigadier:string\": brigadierParsers.stringParser,\n    \"minecraft:block_pos\": coordParsers.blockPos,\n    \"minecraft:block_predicate\": blockParsers.predicateParser,\n    \"minecraft:block_state\": blockParsers.stateParser,\n    \"minecraft:color\": listParsers.colorParser,\n    \"minecraft:dimension\": namespaceParsers.dimensionParser,\n    \"minecraft:entity_anchor\": listParsers.entityAnchorParser,\n    \"minecraft:entity_summon\": namespaceParsers.summonParser,\n    \"minecraft:function\": functionParser,\n    \"minecraft:item_enchantment\": namespaceParsers.enchantmentParser,\n    \"minecraft:item_predicate\": itemParsers.predicate,\n    \"minecraft:item_slot\": listParsers.itemSlotParser,\n    \"minecraft:item_stack\": itemParsers.stack,\n    \"minecraft:message\": messageParser,\n    \"minecraft:mob_effect\": namespaceParsers.mobEffectParser,\n    \"minecraft:objective\": objectiveParser,\n    \"minecraft:operation\": listParsers.operationParser,\n    \"minecraft:particle\": namespaceParsers.particleParser,\n    \"minecraft:resource_location\": resourceParser,\n    \"minecraft:rotation\": coordParsers.rotation,\n    \"minecraft:scoreboard_slot\": listParsers.scoreBoardSlotParser,\n    \"minecraft:team\": teamParser,\n    \"minecraft:vec2\": coordParsers.vec2,\n    \"minecraft:vec3\": coordParsers.vec3\n};\n\nexport function getParser(node: CommandNode): Parser | undefined {\n    switch (node.type) {\n        case \"literal\":\n            return literalParser;\n        case \"argument\":\n            if (!!node.parser) {\n                return getArgParser(node.parser);\n            }\n            break;\n        default:\n    }\n    return undefined;\n}\n\nfunction getArgParser(id: string): Parser | undefined {\n    if (\n        !!global.mcLangSettings &&\n        !!global.mcLangSettings.parsers &&\n        global.mcLangSettings.parsers.hasOwnProperty(id)\n    ) {\n        try {\n            return global.mcLangSettings.parsers[id];\n        } catch (_) {\n            mcLangLog(\n                `${global.mcLangSettings.parsers[id]} could not be loaded`\n            );\n        }\n    }\n    if (implementedParsers.hasOwnProperty(id)) {\n        return implementedParsers[id];\n    }\n    mcLangLog(`Argument with parser id ${id} has no associated parser.\nPlease consider reporting this at https://github.com/Levertion/mcfunction-language-server/issues`);\n    return undefined;\n}\n","import {\n    CompletionItem,\n    CompletionItemKind,\n    CompletionList\n} from \"vscode-languageserver/lib/main\";\n\nimport { StringReader } from \"./brigadier/string-reader\";\nimport { COMMENT_START } from \"./consts\";\nimport { DataManager } from \"./data/manager\";\nimport { CommandNodePath, CommandTree } from \"./data/types\";\nimport { createParserInfo } from \"./misc-functions/creators\";\nimport { followPath, getNextNode } from \"./misc-functions/node-tree\";\nimport { getParser } from \"./parsers/get-parser\";\nimport {\n    CommandContext,\n    CommmandData,\n    FunctionInfo,\n    ParseNode,\n    SuggestResult\n} from \"./types\";\n\nexport function computeCompletions(\n    linenum: number,\n    character: number,\n    document: FunctionInfo,\n    data: DataManager\n): CompletionList {\n    const line = document.lines[linenum];\n    if (line.parseInfo === undefined || line.text.startsWith(COMMENT_START)) {\n        return CompletionList.create([], true);\n    }\n    const commandData: CommmandData = {\n        globalData: data.globalData,\n        localData: data.getPackFolderData(document.pack_segments)\n    };\n    const nodes = line.parseInfo ? line.parseInfo.nodes : [];\n    if (nodes.length === 0) {\n        return CompletionList.create(\n            getCompletionsFromNode(\n                linenum,\n                0,\n                character,\n                line.text,\n                [],\n                commandData,\n                {}\n            ),\n            true\n        );\n    }\n    const finals: ParseNode[] = [];\n    const internals: ParseNode[] = [];\n    for (const node of nodes) {\n        if (node.high < character) {\n            if (node.final) {\n                finals.push(node);\n            }\n        } else {\n            if (node.low <= character) {\n                internals.push(node);\n            }\n        }\n    }\n    const completions: CompletionItem[] = [];\n    for (const finalNode of finals) {\n        completions.push(\n            ...getCompletionsFromNode(\n                linenum,\n                finalNode.high + 1,\n                character,\n                line.text,\n                finalNode.path,\n                commandData,\n                finalNode.context\n            )\n        );\n    }\n    for (const insideNode of internals) {\n        const newPath = insideNode.path.slice();\n        const parentPath = newPath.slice(0, -1);\n        completions.push(\n            ...getCompletionsFromNode(\n                linenum,\n                insideNode.low,\n                character,\n                line.text,\n                parentPath,\n                commandData,\n                insideNode.context\n            )\n        );\n    }\n    return CompletionList.create(completions, true);\n}\n\nfunction getCompletionsFromNode(\n    line: number,\n    start: number,\n    end: number,\n    text: string,\n    nodepath: CommandNodePath,\n    data: CommmandData,\n    context: CommandContext\n): CompletionItem[] {\n    const parent = getNextNode(\n        followPath(data.globalData.commands, nodepath),\n        nodepath,\n        (data.globalData.commands as any) as CommandTree\n    ).node;\n    const result: CompletionItem[] = [];\n    if (!!parent.children) {\n        for (const childKey in parent.children) {\n            if (parent.children.hasOwnProperty(childKey)) {\n                const child = parent.children[childKey];\n                const childPath = [...nodepath, childKey];\n                const info = createParserInfo(\n                    child,\n                    data,\n                    childPath,\n                    context,\n                    true\n                );\n                const parser = getParser(child);\n                if (!!parser) {\n                    const reader = new StringReader(text.substring(start, end));\n                    const parseResult = parser.parse(reader, info);\n                    if (!!parseResult) {\n                        result.push(\n                            ...suggestionsToCompletions(\n                                parseResult.suggestions,\n                                line,\n                                start,\n                                end,\n                                parser.kind\n                            )\n                        );\n                    }\n                }\n            }\n        }\n    }\n    return result;\n}\n\nfunction suggestionsToCompletions(\n    suggestions: SuggestResult[],\n    line: number,\n    start: number,\n    end: number,\n    defaultKind: CompletionItemKind = CompletionItemKind.Keyword\n): CompletionItem[] {\n    const result: CompletionItem[] = [];\n    for (const suggestion of suggestions) {\n        if (typeof suggestion === \"string\") {\n            result.push({\n                kind: defaultKind,\n                label: suggestion,\n                textEdit: {\n                    newText: suggestion,\n                    range: {\n                        end: { character: end, line },\n                        start: { character: start, line }\n                    }\n                }\n            });\n        } else {\n            const completion: CompletionItem = {\n                kind: suggestion.kind || defaultKind,\n                label: suggestion.text,\n                textEdit: {\n                    newText: suggestion.text,\n                    range: {\n                        end: { character: end, line },\n                        start: { character: start + suggestion.start, line }\n                    }\n                }\n            };\n            if (!!suggestion.description) {\n                completion.detail = suggestion.description;\n            }\n            result.push(completion);\n        }\n    }\n    return result;\n}\n","import { resourceTypes, ReturnHelper } from \"../../misc-functions\";\nimport { typed_keys } from \"../../misc-functions/third_party/typed-keys\";\n\nimport { join } from \"path\";\nimport { ReturnSuccess } from \"../../types\";\nimport { GlobalData, Resources, WorldInfo } from \"../types\";\n\nexport async function runMapFunctions(\n    resources: Resources,\n    globalData: GlobalData,\n    packRoot: string,\n    localData?: WorldInfo\n): Promise<ReturnSuccess<Resources>> {\n    const result: Resources = {};\n    const helper = new ReturnHelper();\n    const promises: Array<Promise<void>> = [];\n    for (const type of typed_keys(resources)) {\n        type resourcesType = NonNullable<Resources[typeof type]>;\n        const val = (result[type] = [] as resourcesType);\n        const data = resources[type] as resourcesType;\n        // tslint:disable-next-line:no-unbound-method We control this function, so we know it won't use the this keyword.\n        const mapFunction = resourceTypes[type].mapFunction;\n        if (mapFunction) {\n            promises.push(\n                ...data.map(async v => {\n                    const res = await mapFunction(\n                        v,\n                        packRoot,\n                        globalData,\n                        localData\n                    );\n                    helper.merge(res);\n                    val.push(res.data);\n                })\n            );\n        } else {\n            val.push(...data);\n        }\n    }\n    await Promise.all(promises);\n    return helper.succeed(result);\n}\n\nexport async function mapPacksInfo(\n    packsInfo: WorldInfo,\n    global: GlobalData\n): Promise<ReturnSuccess<WorldInfo>> {\n    const helper = new ReturnHelper();\n    const result: WorldInfo = { ...packsInfo, packs: {} };\n    const promises = typed_keys(packsInfo.packs).map(async packID => {\n        const element = packsInfo.packs[packID];\n        const subresult = await runMapFunctions(\n            element.data,\n            global,\n            join(packsInfo.location, element.name),\n            packsInfo\n        );\n        helper.merge(subresult);\n        result.packs[packID] = { ...element, data: subresult.data };\n    });\n    await Promise.all(promises);\n    return helper.succeed(result);\n}\n","import * as Long from \"long\";\n\nexport class BufferStream {\n    private readonly buf: Buffer;\n    private index: number;\n\n    public constructor(buffer: Buffer) {\n        this.index = 0;\n        this.buf = buffer;\n    }\n\n    public getByte(): number {\n        const out = this.buf.readInt8(this.index);\n        this.index++;\n        return out;\n    }\n\n    public getDouble(): number {\n        const out = this.buf.readDoubleBE(this.index);\n        this.index += 8;\n        return out;\n    }\n\n    public getFloat(): number {\n        const out = this.buf.readFloatBE(this.index);\n        this.index += 4;\n        return out;\n    }\n\n    public getInt(): number {\n        const out = this.buf.readInt32BE(this.index);\n        this.index += 4;\n        return out;\n    }\n\n    public getLong(): Long {\n        const arr = this.buf.subarray(this.index, this.index + 8);\n        this.index += 8;\n        return Long.fromBytesBE([...arr]);\n    }\n\n    public getShort(): number {\n        const out = this.buf.readInt16BE(this.index);\n        this.index += 2;\n        return out;\n    }\n\n    public getUTF8(): string {\n        const len = this.getShort();\n        const out = this.buf.toString(\"utf8\", this.index, this.index + len);\n        this.index += len;\n        return out;\n    }\n}\n","import { promisify } from \"util\";\nimport * as zlib from \"zlib\";\nimport { BufferStream } from \"./buffer-stream\";\n\nconst unzipAsync = promisify<zlib.InputType, Buffer>(zlib.unzip);\n\nlet tags: Tag;\n\ntype tagparser<T> = (buffer: BufferStream) => T;\n\nconst nbtbyte = (buffer: BufferStream) => buffer.getByte();\nconst nbtshort = (buffer: BufferStream) => buffer.getShort();\nconst nbtint = (buffer: BufferStream) => buffer.getInt();\nconst nbtlong = (buffer: BufferStream) => buffer.getLong();\nconst nbtfloat = (buffer: BufferStream) => buffer.getFloat();\nconst nbtdouble = (buffer: BufferStream) => buffer.getDouble();\n\nconst nbtbytearray = (buffer: BufferStream) => {\n    const len = buffer.getInt();\n    const out: number[] = [];\n    for (let i = 0; i < len; i++) {\n        out.push(buffer.getByte());\n    }\n    return out;\n};\n\nconst nbtstring = (buffer: BufferStream) => buffer.getUTF8();\n\nconst nbtlist = (buffer: BufferStream) => {\n    const id = buffer.getByte();\n    const len = buffer.getInt();\n    const parser = tags[id];\n    const out: any[] = [];\n    for (let i = 0; i < len; i++) {\n        out.push(parser(buffer));\n    }\n    return out;\n};\n\nconst nbtcompound = (buffer: BufferStream) => {\n    let tag: number = buffer.getByte();\n    const out: { [key: string]: any } = {};\n    while (tag !== 0) {\n        const name = buffer.getUTF8();\n        const parser = tags[tag];\n        out[name] = parser(buffer);\n        tag = buffer.getByte();\n    }\n    return out;\n};\n\nconst nbtintarray = (buffer: BufferStream) => {\n    const len = buffer.getInt();\n    const out: number[] = [];\n    for (let i = 0; i < len; i++) {\n        out.push(buffer.getInt());\n    }\n    return out;\n};\n\nconst nbtlongarray = (buffer: BufferStream) => {\n    const len = buffer.getInt();\n    const out: Long[] = [];\n    for (let i = 0; i < len; i++) {\n        out.push(buffer.getLong());\n    }\n    return out;\n};\n\ninterface Tag {\n    [id: number]: tagparser<any>;\n}\n\ntags = {\n    // Need to redeclare because of TSLint\n    1: nbtbyte,\n    2: nbtshort,\n    3: nbtint,\n    4: nbtlong,\n    5: nbtfloat,\n    6: nbtdouble,\n    7: nbtbytearray,\n    8: nbtstring,\n    9: nbtlist,\n    10: nbtcompound,\n    11: nbtintarray,\n    12: nbtlongarray\n};\n\nexport async function parse<T>(\n    buffer: Buffer,\n    named: boolean = true\n): Promise<T> {\n    let unzipbuf;\n    try {\n        unzipbuf = await unzipAsync(buffer);\n    } catch (e) {\n        unzipbuf = buffer;\n    }\n    const stream = new BufferStream(unzipbuf);\n    const id = stream.getByte();\n    if (named) {\n        stream.getUTF8(); // Name\n    }\n    const parser = tags[id];\n    return parser(stream) as T;\n}\n","import * as path from \"path\";\nimport { readFileAsync } from \"../../misc-functions\";\nimport { WorldNBT } from \"../types\";\nimport { Level, Scoreboard } from \"./nbt-types\";\nimport { parse } from \"./parser\";\n\nexport async function loadNBT(worldLoc: string): Promise<WorldNBT> {\n    const nbt: WorldNBT = {} as WorldNBT;\n\n    const levelpath = path.resolve(worldLoc, \"./level.dat\");\n    try {\n        const levelbuf: Buffer = await readFileAsync(levelpath);\n        nbt.level = await parse<Level>(levelbuf);\n    } catch (e) {\n        // Level doesn't exist\n    }\n\n    const scpath = path.resolve(worldLoc, \"./data/scoreboards.dat\");\n    try {\n        const scoreboardbuf: Buffer = await readFileAsync(scpath);\n        nbt.scoreboard = await parse<Scoreboard>(scoreboardbuf);\n    } catch (e) {\n        // Scoreboard file doesn't exist\n    }\n\n    return nbt;\n}\n","import * as path from \"path\";\n\nimport { DATAFOLDER, MCMETAFILE, SLASH } from \"../consts\";\nimport { resourceTypes, ReturnHelper } from \"../misc-functions\";\nimport { createExtensionFileError } from \"../misc-functions/file-errors\";\nimport {\n    readDirAsync,\n    readJSON,\n    statAsync,\n    walkDir\n} from \"../misc-functions/promisified-fs\";\nimport { typed_keys } from \"../misc-functions/third_party/typed-keys\";\nimport { ReturnSuccess } from \"../types\";\nimport { mapPacksInfo } from \"./extractor/mapfunctions\";\nimport { loadNBT } from \"./nbt/nbt-cache\";\nimport {\n    Datapack,\n    DataPackID,\n    GlobalData,\n    McmetaFile,\n    MinecraftResource,\n    Resources,\n    WorldInfo\n} from \"./types\";\n\nexport async function getNamespaceResources(\n    namespace: string,\n    dataFolder: string,\n    id: DataPackID | undefined,\n    result: Resources = {}\n): Promise<ReturnSuccess<Resources>> {\n    const helper = new ReturnHelper();\n    const namespaceFolder = path.join(dataFolder, namespace);\n    const subDirs = await subDirectories(namespaceFolder);\n    await Promise.all(\n        typed_keys(resourceTypes).map(async type => {\n            const resourceInfo = resourceTypes[type];\n            if (subDirs.indexOf(resourceInfo.path[0]) === -1) {\n                return;\n            }\n            const dataContents = path.join(\n                namespaceFolder,\n                ...resourceInfo.path\n            );\n            const files = await walkDir(dataContents);\n            if (files.length === 0) {\n                return;\n            }\n            const nameSpaceContents = result[type] || [];\n            await Promise.all(\n                files.map(async file => {\n                    const realExtension = path.extname(file);\n                    if (realExtension !== resourceInfo.extension) {\n                        helper.addMisc(\n                            createExtensionFileError(\n                                file,\n                                resourceInfo.extension,\n                                realExtension\n                            )\n                        );\n                    }\n                    const internalUri = path.relative(dataContents, file);\n                    const newResource: MinecraftResource = {\n                        namespace,\n                        pack: id,\n                        path: internalUri\n                            .slice(0, -realExtension.length)\n                            .replace(path.sep, SLASH)\n                    };\n                    nameSpaceContents.push(newResource);\n                })\n            );\n            result[type] = nameSpaceContents;\n        })\n    );\n\n    return helper.succeed(result);\n}\n\nasync function buildDataPack(\n    packFolder: string,\n    id: DataPackID,\n    packName: string\n): Promise<ReturnSuccess<Datapack>> {\n    const helper = new ReturnHelper();\n    const dataFolder = path.join(packFolder, DATAFOLDER);\n    const [mcmeta, packResources] = await Promise.all([\n        readJSON<McmetaFile>(path.join(packFolder, MCMETAFILE)),\n        getPackResources(dataFolder, id)\n    ]);\n    const result: Datapack = { id, data: packResources.data, name: packName };\n    helper.merge(packResources);\n    if (helper.merge(mcmeta)) {\n        result.mcmeta = mcmeta.data;\n    }\n    return helper.succeed(result);\n}\n\nasync function getPackResources(\n    dataFolder: string,\n    id: DataPackID\n): Promise<ReturnSuccess<Resources>> {\n    const helper = new ReturnHelper();\n    const namespaces = await subDirectories(dataFolder);\n    const result: Resources = {};\n    await Promise.all(\n        namespaces.map(async namespace => {\n            const resources = await getNamespaceResources(\n                namespace,\n                dataFolder,\n                id,\n                result\n            );\n            helper.merge(resources);\n            return resources.data;\n        })\n    );\n    return helper.succeed(result);\n}\n\nexport async function getPacksInfo(\n    location: string,\n    globalData: GlobalData\n): Promise<ReturnSuccess<WorldInfo>> {\n    const packNames = await subDirectories(location);\n    const helper = new ReturnHelper();\n    const packs = [...packNames.entries()];\n    const nbt = await loadNBT(path.resolve(location, \"../\"));\n    const result: WorldInfo = { location, packnamesmap: {}, packs: {}, nbt };\n    const promises: Array<Promise<void>> = packs.map(\n        async ([packID, packName]) => {\n            const loc = path.join(location, packName);\n            const packData = await buildDataPack(loc, packID, packName);\n            helper.merge(packData);\n            result.packs[packID] = packData.data;\n            result.packnamesmap[packName] = packID;\n        }\n    );\n    await Promise.all(promises);\n    const otherResult = await mapPacksInfo(result, globalData);\n    return helper.mergeChain(otherResult).succeed(otherResult.data);\n}\n\nasync function subDirectories(baseFolder: string): Promise<string[]> {\n    let files: string[] = [];\n    try {\n        files = await readDirAsync(baseFolder);\n    } catch {\n        return [];\n    }\n    const promises = files.map<Promise<boolean>>(async name => {\n        try {\n            return (await statAsync(path.join(baseFolder, name))).isDirectory();\n        } catch {\n            return false;\n        }\n    });\n    const results = await Promise.all(promises);\n    return files.filter((_, i) => results[i]);\n}\n","import * as fs from \"fs\";\nimport * as path from \"path\";\nimport { shim } from \"util.promisify\";\nshim();\nimport { promisify } from \"util\";\n\nimport { DATAFOLDER } from \"../../consts\";\nimport { ReturnHelper } from \"../../misc-functions\";\nimport { ReturnSuccess } from \"../../types\";\nimport { getNamespaceResources } from \"../datapack-resources\";\nimport { BlocksPropertyInfo, CommandTree, GlobalData } from \"../types\";\nimport { runMapFunctions } from \"./mapfunctions\";\nconst readFileAsync = promisify(fs.readFile);\n\ntype DataSaveResult<T extends keyof GlobalData> = [T, GlobalData[T]];\n\nexport async function collectData(\n    version: string,\n    dataDir: string\n): Promise<ReturnSuccess<GlobalData>> {\n    const helper = new ReturnHelper();\n    const result: GlobalData = { meta_info: { version } } as GlobalData;\n    const cleanups = await Promise.all([\n        getBlocks(dataDir),\n        getItems(dataDir),\n        getCommands(dataDir),\n        getResources(dataDir)\n    ]);\n    for (const dataType of cleanups) {\n        result[dataType[0]] = dataType[1];\n    }\n    const resources = await runMapFunctions(result.resources, result, dataDir);\n    return helper\n        .mergeChain(resources)\n        .succeed({ ...result, resources: resources.data });\n}\n\n//#region Resources\nasync function getResources(\n    dataDir: string\n): Promise<DataSaveResult<\"resources\">> {\n    const namespacePath = path.join(dataDir, DATAFOLDER);\n    const resources = await getNamespaceResources(\n        \"minecraft\",\n        namespacePath,\n        undefined\n    );\n    return [\"resources\", resources.data];\n}\n//#endregion\n//#region Items\nasync function getItems(dataDir: string): Promise<DataSaveResult<\"items\">> {\n    const itemsData: Dictionary<{ protocol_id: number }> = JSON.parse(\n        (await readFileAsync(\n            path.join(dataDir, \"reports\", \"items.json\")\n        )).toString()\n    );\n    return [\"items\", Object.keys(itemsData)];\n}\nasync function getCommands(\n    dataDir: string\n): Promise<DataSaveResult<\"commands\">> {\n    const tree: CommandTree = JSON.parse(\n        (await readFileAsync(\n            path.join(dataDir, \"reports\", \"commands.json\")\n        )).toString()\n    );\n    return [\"commands\", tree];\n}\n//#endregion\n\n//#region Blocks\nasync function getBlocks(dataDir: string): Promise<DataSaveResult<\"blocks\">> {\n    const blocksData: BlocksJson = JSON.parse(\n        (await readFileAsync(\n            path.join(dataDir, \"reports\", \"blocks.json\")\n        )).toString()\n    );\n    return [\"blocks\", cleanBlocks(blocksData)];\n}\n\nfunction cleanBlocks(blocks: BlocksJson): BlocksPropertyInfo {\n    const result: BlocksPropertyInfo = {};\n    for (const blockName in blocks) {\n        if (blocks.hasOwnProperty(blockName)) {\n            const blockInfo = blocks[blockName];\n            result[blockName] = {};\n            if (!!blockInfo.properties) {\n                Object.assign(result[blockName], blockInfo.properties);\n            }\n        }\n    }\n    return result;\n}\n\ninterface BlocksJson {\n    [id: string]: {\n        properties?: {\n            [id: string]: string[];\n        };\n    };\n}\n//#endregion\n","// tslint:disable:no-require-imports\nimport * as fs from \"fs\";\nimport * as path from \"path\";\n// @ts-ignore `import *` syntax is broken in this case as requestPromise would be a function\nimport requestPromise from \"request-promise-native\";\n\nexport async function getPathToJar(\n    tempdir: string,\n    currentversion: string\n): Promise<JarInfo> {\n    if (!!mcLangSettings.data.customJar) {\n        return { jarPath: mcLangSettings.data.customJar, version: \"\" };\n    } else {\n        return downloadJar(currentversion, tempdir);\n    }\n}\n\nexport async function downloadJar(\n    currentversion: string,\n    tmpDirName: string\n): Promise<JarInfo> {\n    const versionInfo = await getLatestVersionInfo();\n    if (versionInfo.id !== currentversion) {\n        const singleVersion: SingleVersionInformation = await requestPromise(\n            versionInfo.url,\n            {\n                json: true\n            }\n        ).promise();\n        const jarPath = path.join(\n            tmpDirName,\n            `minecraft-function-${versionInfo.id}.jar`\n        );\n        const requestPromised = requestPromise(\n            singleVersion.downloads.server.url\n        );\n        requestPromised.pipe(fs.createWriteStream(jarPath));\n        await Promise.resolve(requestPromised);\n        return { jarPath, version: versionInfo.id };\n    } else {\n        throw new Error(\n            \"Downloading new global data not needed as current version is the same as the latest version.\"\n        );\n    }\n}\n\nexport interface JarInfo {\n    jarPath: string;\n    version: string;\n}\n\n//#region Version Manifest Usage\ninterface SingleVersionInformation {\n    downloads: {\n        server: {\n            sha1: string;\n            size: number;\n            url: string;\n        };\n    };\n}\n\nasync function getLatestVersionInfo(): Promise<VersionInfo> {\n    const manifest: VersionsManifest = await requestPromise(\n        \"https://launchermeta.mojang.com/mc/game/version_manifest.json\",\n        {\n            json: true\n        }\n    ).promise();\n    const version = findVersion(getVersionId(manifest), manifest);\n    return version;\n}\n\nfunction getVersionId(manifest: VersionsManifest): string {\n    if (mcLangSettings.data.snapshots) {\n        return manifest.latest.snapshot;\n    } else {\n        return manifest.latest.release;\n    }\n}\n\nfunction findVersion(version: string, manifest: VersionsManifest): VersionInfo {\n    return manifest.versions.find(\n        verInfo => verInfo.id === version\n    ) as VersionInfo;\n}\n\ninterface VersionInfo {\n    id: string;\n    releaseTime: string;\n    time: string;\n    type: \"snapshot\" | \"release\";\n    url: string;\n}\n\ninterface VersionsManifest {\n    latest: {\n        release: string;\n        snapshot: string;\n    };\n    versions: VersionInfo[];\n}\n//#endregion\n","import { execFile } from \"child_process\";\nimport * as path from \"path\";\nimport { shim } from \"util.promisify\";\nshim();\nimport { promisify } from \"util\";\nconst execFileAsync = promisify(execFile);\n\n/**\n * Get the command used to execute a java version\n */\nexport async function checkJavaPath(): Promise<string> {\n    const javaPath = mcLangSettings.data.javaPath || \"java\";\n    try {\n        await execFileAsync(javaPath, [\"-version\"], { env: process.env });\n        return javaPath;\n    } catch (error) {\n        throw new Error(\n            `Could not find Java executable. Got message: '${error}'`\n        );\n    }\n}\n\nexport async function runGenerator(\n    javapath: string,\n    tempdir: string,\n    jarpath: string\n): Promise<string> {\n    const resultFolder = path.join(tempdir, \"generated\");\n    await execFileAsync(javapath, [\n        \"-cp\",\n        jarpath,\n        \"net.minecraft.data.Main\",\n        \"--output\",\n        resultFolder,\n        \"--all\"\n    ]);\n    return resultFolder;\n}\n","import * as fs from \"fs\";\nimport { tmpdir } from \"os\";\nimport * as path from \"path\";\nimport { shim } from \"util.promisify\";\nshim();\nimport { promisify } from \"util\";\n\nimport { ReturnHelper } from \"../../misc-functions\";\nimport { ReturnSuccess } from \"../../types\";\nimport { cacheData } from \"../cache\";\nimport { GlobalData } from \"../types\";\nimport { collectData } from \"./collect-data\";\nimport { getPathToJar } from \"./download\";\nimport { checkJavaPath, runGenerator } from \"./extract-data\";\n\nconst mkdtmpAsync = promisify(fs.mkdtemp);\n\n/**\n * Will throw an error if something goes wrong.\n * Steps:\n * - Check if enabled in settings. \n * - Check versions manifest. Compare with cached if available \n *  - At the same time, check if java is installed \n * - Get single version information \n * - Download the jar into a temporary folder \n * - Run the exposed data generator. \n * - Collect the data exposed\n *  - Blocks and states\n *  - Items\n *  - (Entities)?\n *  - Commands\n *  - Advancements, recipes, structures, tags, etc\n * - Cache that data\n * - Return the data\n */\nexport async function collectGlobalData(\n    currentversion: string = \"\"\n): Promise<ReturnSuccess<GlobalData>> {\n    if (mcLangSettings.data.enabled) {\n        const javaPath = await checkJavaPath();\n        const dir = await mkdtmpAsync(path.join(tmpdir(), \"mcfunction\"));\n        const jarInfo = await getPathToJar(dir, currentversion);\n        const datadir = await runGenerator(javaPath, dir, jarInfo.jarPath);\n        mcLangLog(\"Generator Finished\");\n        const helper = new ReturnHelper();\n        const data = await collectData(jarInfo.version, datadir);\n        await cacheData(data.data);\n        return helper.mergeChain(data).succeed(data.data);\n    } else {\n        throw new Error(\n            \"Data Obtainer disabled in settings. To obtain data automatically, please enable it.\"\n        );\n    }\n}\n","import { NonCacheable } from \"./types\";\n\nexport async function loadNonCached(): Promise<NonCacheable> {\n    return {};\n}\n","import {\n    DidChangeWatchedFilesParams,\n    FileChangeType\n} from \"vscode-languageserver\";\n\nimport { extname, join } from \"path\";\nimport { MCMETAFILE } from \"../consts\";\nimport {\n    getKindAndNamespace,\n    namespacesEqual,\n    PackLocationSegments,\n    parseDataPath,\n    resourceTypes,\n    ReturnHelper\n} from \"../misc-functions\";\nimport { createExtensionFileError } from \"../misc-functions/file-errors\";\nimport { readJSON } from \"../misc-functions/promisified-fs\";\nimport { ReturnedInfo, ReturnSuccess } from \"../types\";\nimport { readCache } from \"./cache\";\nimport { getPacksInfo } from \"./datapack-resources\";\nimport { collectGlobalData } from \"./extractor\";\nimport { loadNonCached } from \"./noncached\";\nimport {\n    Datapack,\n    DataPackID,\n    GlobalData,\n    LocalData,\n    McmetaFile,\n    MinecraftResource,\n    WorldInfo\n} from \"./types\";\n\nexport class DataManager {\n    /**\n     * Create a datamanager using Dummy Data for running tests.\n     */\n    public static newWithData(\n        dummyGlobal?: DataManager[\"globalDataInternal\"],\n        dummyPacks?: DataManager[\"packDataComplete\"]\n    ): DataManager {\n        const manager = new DataManager();\n\n        manager.globalDataInternal = dummyGlobal || manager.globalDataInternal;\n        Object.assign(manager.packDataComplete, dummyPacks);\n        return manager;\n    }\n    //#region Data Management\n    private globalDataInternal: GlobalData = {} as GlobalData;\n\n    private readonly packDataComplete: { [root: string]: WorldInfo } = {};\n\n    private readonly packDataPromises: {\n        [root: string]: Promise<ReturnSuccess<WorldInfo>>;\n    } = {};\n\n    public get globalData(): GlobalData {\n        return this.globalDataInternal;\n    }\n    //#endregion\n    //#region Constructor\n    //#endregion\n    public getPackFolderData(\n        folder: PackLocationSegments | undefined\n    ): LocalData | undefined {\n        if (\n            !!folder &&\n            this.packDataComplete.hasOwnProperty(folder.packsFolder)\n        ) {\n            const info = this.packDataComplete[folder.packsFolder];\n\n            return { ...info, current: info.packnamesmap[folder.pack] };\n        }\n        return undefined;\n    }\n\n    public async handleChanges(\n        event: DidChangeWatchedFilesParams\n    ): Promise<ReturnedInfo<undefined>> {\n        const helper = new ReturnHelper(false);\n        const firsts = new Set<string>();\n        const promises = event.changes.map(async change => {\n            try {\n                const parsedPath = parseDataPath(change.uri);\n                if (parsedPath) {\n                    interface InlineData {\n                        data: WorldInfo;\n                        pack: Datapack;\n                        packID: DataPackID;\n                    }\n                    const getData = async (): Promise<InlineData> => {\n                        const first = await this.readPackFolderData(\n                            parsedPath.packsFolder\n                        );\n                        if (first) {\n                            firsts.add(parsedPath.packsFolder);\n                        }\n                        const data = this.getPackFolderData(parsedPath);\n                        if (!data) {\n                            throw new Error(\n                                \"Could not load data from datapacks folder\"\n                            );\n                        }\n                        const packID = data.packnamesmap[parsedPath.pack];\n                        const pack = data.packs[packID];\n                        return { data, pack, packID };\n                    };\n\n                    if (parsedPath.rest === MCMETAFILE) {\n                        const { pack } = await getData();\n                        if (!firsts.has(parsedPath.packsFolder)) {\n                            const res = await readJSON<McmetaFile>(change.uri);\n                            pack.mcmeta = helper.merge(res)\n                                ? res.data\n                                : undefined;\n                        }\n                    } else {\n                        const namespace = getKindAndNamespace(parsedPath.rest);\n                        if (namespace) {\n                            const { pack, packID, data } = await getData();\n                            if (!firsts.has(parsedPath.packsFolder)) {\n                                const shouldUpdateContents =\n                                    change.type === FileChangeType.Changed &&\n                                    resourceTypes[namespace.kind].mapFunction;\n                                let contents = pack.data[namespace.kind];\n                                if (\n                                    (change.type === FileChangeType.Deleted ||\n                                        shouldUpdateContents) &&\n                                    !!contents\n                                ) {\n                                    for (let i = 0; i < contents.length; i++) {\n                                        const element = contents[i];\n                                        if (\n                                            namespacesEqual(\n                                                element,\n                                                namespace.location\n                                            )\n                                        ) {\n                                            contents.splice(i, 1);\n                                            break;\n                                        }\n                                    }\n                                }\n                                if (\n                                    change.type === FileChangeType.Created ||\n                                    shouldUpdateContents\n                                ) {\n                                    if (!contents) {\n                                        contents = pack.data[\n                                            namespace.kind\n                                        ] = [];\n                                    }\n                                    const newResource: MinecraftResource = {\n                                        ...namespace.location,\n                                        pack: packID\n                                    };\n                                    const actual = extname(change.uri);\n                                    const expected =\n                                        resourceTypes[namespace.kind].extension;\n                                    if (actual === expected) {\n                                        const mapFunction =\n                                            // tslint:disable-next-line:no-unbound-method We control this function, so we know it won't use the this keyword.\n                                            resourceTypes[namespace.kind]\n                                                .mapFunction;\n                                        if (mapFunction) {\n                                            const result = await mapFunction(\n                                                newResource,\n                                                join(\n                                                    parsedPath.packsFolder,\n                                                    parsedPath.pack\n                                                ),\n                                                this.globalData,\n                                                data\n                                            );\n                                            if (helper.merge(result)) {\n                                                contents.push(result.data);\n                                            }\n                                        } else {\n                                            contents.push(newResource);\n                                        }\n                                    } else {\n                                        helper.addMisc(\n                                            createExtensionFileError(\n                                                change.uri,\n                                                expected,\n                                                actual\n                                            )\n                                        );\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            } catch (error) {\n                mcLangLog(\n                    `Change ${JSON.stringify(\n                        change\n                    )} could not be completed, due to '${JSON.stringify(\n                        error\n                    )}'`\n                );\n            }\n        });\n        await Promise.all(promises);\n        return helper.succeed();\n    }\n\n    public async loadGlobalData(): Promise<true | string> {\n        let version: string | undefined;\n        if (!!this.globalData.meta_info) {\n            version = this.globalData.meta_info.version;\n        }\n        try {\n            const helper = new ReturnHelper();\n            const data = await collectGlobalData(version);\n            helper.merge(data);\n            this.globalDataInternal = data.data;\n            return true;\n        } catch (error) {\n            return `Error loading global data: ${error.stack ||\n                error.toString()}`;\n        }\n    }\n\n    public async readCache(): Promise<boolean> {\n        try {\n            const cache = await readCache();\n            const noncache = await loadNonCached();\n            this.globalDataInternal = { ...cache, ...noncache };\n            mcLangLog(\"Cache Successfully read\");\n            return true;\n        } catch (error) {\n            mcLangLog(\n                `Reading cache failed with error ${JSON.stringify(error)}`\n            );\n            return false;\n        }\n    }\n\n    /**\n     * @returns Whether this is the first request for this folder\n     */\n    public async readPackFolderData(\n        folder: string\n    ): Promise<ReturnedInfo<void>> {\n        const helper = new ReturnHelper();\n        if (!this.packDataPromises.hasOwnProperty(folder)) {\n            this.packDataPromises[folder] = getPacksInfo(\n                folder,\n                this.globalData\n            );\n            const result = await this.packDataPromises[folder];\n            this.packDataComplete[folder] = result.data;\n            helper.merge(result);\n            return helper.succeed();\n        } else {\n            await this.packDataPromises[folder];\n            return helper.fail();\n        }\n    }\n}\n","/**\n * merge_deep function adapted from:\n *\n * https://stackoverflow.com/a/34749873/8728461\n *\n * Originally, non-typescript code by: https://github.com/salakar\n */\n\ntype AnyDict = Dictionary<any>;\n\n/**\n * Simple object check.\n */\nexport function isObject(item: any): item is AnyDict {\n    return item && typeof item === \"object\" && !Array.isArray(item);\n}\n\n/**\n * Deep merge two objects.\n */\nexport function mergeDeep(target: AnyDict, ...sources: AnyDict[]): AnyDict {\n    if (!sources.length) {\n        return target;\n    }\n    const source = sources.shift();\n    if (isObject(target) && isObject(source)) {\n        for (const key in source) {\n            if (isObject(source[key])) {\n                if (!target[key]) {\n                    Object.assign(target, { [key]: {} });\n                }\n                mergeDeep(target[key], source[key]);\n            } else {\n                Object.assign(target, { [key]: source[key] });\n            }\n        }\n    }\n    return mergeDeep(target, ...sources);\n}\n","import { EventEmitter } from \"events\";\nimport { DiagnosticSeverity } from \"vscode-languageserver/lib/main\";\n\nimport { CommandErrorBuilder } from \"./brigadier/errors\";\nimport { StringReader } from \"./brigadier/string-reader\";\nimport { COMMENT_START, SPACE } from \"./consts\";\nimport { DataManager } from \"./data/manager\";\nimport {\n    CommandNode,\n    CommandNodePath,\n    GlobalData,\n    LocalData\n} from \"./data/types\";\nimport {\n    createParserInfo,\n    getNextNode,\n    isSuccessful,\n    ReturnHelper\n} from \"./misc-functions\";\nimport { getParser } from \"./parsers/get-parser\";\nimport {\n    CommandContext,\n    CommmandData,\n    FunctionInfo,\n    ParseNode,\n    ReturnedInfo,\n    StoredParseResult\n} from \"./types\";\n\nconst parseExceptions = {\n    Ambiguity: new CommandErrorBuilder(\n        \"parsing.command.ambiguous\",\n        \"Command text is possibly ambiguous\",\n        DiagnosticSeverity.Information\n    ),\n    NoSuccesses: new CommandErrorBuilder(\n        \"command.parsing.matchless\",\n        \"No nodes which matched '%s' found\"\n    ),\n    NotRunnable: new CommandErrorBuilder(\n        \"parsing.command.executable\",\n        \"The command '%s' cannot be run.\",\n        DiagnosticSeverity.Warning\n    )\n};\n\nexport function parseCommand(\n    text: string,\n    globalData: GlobalData,\n    localData: LocalData | undefined\n): StoredParseResult | void {\n    if (text.length === 0 || text.startsWith(COMMENT_START)) {\n        return undefined;\n    }\n    const reader = new StringReader(text);\n    const data: CommmandData = { globalData, localData };\n    const startingcontext: CommandContext = {};\n    const recurse = parsechildren(\n        reader,\n        globalData.commands as any,\n        [],\n        data,\n        startingcontext\n    );\n    const nodes: ParseNode[] = [];\n    if (isSuccessful(recurse)) {\n        nodes.push(...recurse.data);\n    }\n    return { actions: recurse.actions, nodes, errors: recurse.errors };\n}\n\nfunction parsechildren(\n    reader: StringReader,\n    node: CommandNode,\n    path: CommandNodePath,\n    data: CommmandData,\n    context: CommandContext\n): ReturnedInfo<ParseNode[]> {\n    const parent = getNextNode(node, path, data.globalData.commands);\n    const helper = new ReturnHelper();\n    const children = parent.node.children;\n    if (children) {\n        const nodes: ParseNode[] = [];\n        const start = reader.cursor;\n        let successCount = 0;\n        let min: number = reader.getTotalLength();\n        for (const childKey of Object.keys(children)) {\n            const child = children[childKey];\n            const childpath = [...parent.path, childKey];\n            const result = parseAgainstNode(\n                reader,\n                child,\n                childpath,\n                data,\n                context\n            );\n            if (helper.merge(result)) {\n                const newNode: ParseNode = {\n                    context,\n                    final: true,\n                    high: reader.cursor,\n                    low: start,\n                    path: childpath\n                };\n                const childdata = result.data;\n                function checkRead(): boolean {\n                    if (reader.canRead()) {\n                        return true;\n                    } else {\n                        if (!childdata.node.executable) {\n                            helper.addErrors(\n                                parseExceptions.NotRunnable.create(\n                                    0,\n                                    reader.cursor,\n                                    reader.string\n                                )\n                            );\n                        }\n                        return false;\n                    }\n                }\n                if (checkRead()) {\n                    if (reader.peek() === SPACE) {\n                        successCount++;\n                        reader.skip();\n                        if (checkRead()) {\n                            const newContext = childdata.newContext\n                                ? childdata.newContext\n                                : context;\n                            const recurse = parsechildren(\n                                reader,\n                                childdata.node,\n                                childpath,\n                                data,\n                                newContext\n                            );\n                            if (helper.merge(recurse)) {\n                                min = Math.min(min, reader.cursor);\n                                nodes.push(...recurse.data);\n                                newNode.final = false;\n                            }\n                        }\n                        nodes.push(newNode);\n                    }\n                } else {\n                    successCount++;\n                    nodes.push(newNode);\n                }\n            }\n            reader.cursor = start;\n        }\n        if (successCount === 0) {\n            return helper.fail(\n                parseExceptions.NoSuccesses.create(\n                    reader.cursor,\n                    reader.getTotalLength(),\n                    reader.getRemaining()\n                )\n            );\n        }\n        if (successCount > 1) {\n            helper.addErrors(parseExceptions.Ambiguity.create(start, min));\n        }\n        return helper.succeed(nodes);\n    } else {\n        if (!(parent.node as CommandNode).executable) {\n            mcLangLog(\n                `Malformed tree at path ${JSON.stringify(\n                    path\n                )}. No children and not executable`\n            );\n        }\n        return helper.fail();\n    }\n}\n\ninterface NodeParseSuccess {\n    max: number;\n    newContext?: CommandContext;\n    node: CommandNode;\n}\n\nfunction parseAgainstNode(\n    reader: StringReader,\n    node: CommandNode,\n    path: CommandNodePath,\n    data: CommmandData,\n    context: CommandContext\n): ReturnedInfo<NodeParseSuccess> {\n    const parser = getParser(node);\n    const helper = new ReturnHelper(false);\n    if (!!parser) {\n        const result = parser.parse(\n            reader,\n            createParserInfo(node, data, path, context, false)\n        );\n        if (!!result) {\n            if (helper.merge(result)) {\n                const newContext = { ...context, ...result.data };\n                return helper.succeed<NodeParseSuccess>({\n                    max: reader.cursor,\n                    newContext,\n                    node\n                });\n            } else {\n                return helper.fail();\n            }\n        } else {\n            return helper.succeed<NodeParseSuccess>({\n                max: reader.cursor,\n                node\n            });\n        }\n    } else {\n        return helper.fail();\n    }\n}\n\nexport function parseLines(\n    document: FunctionInfo,\n    data: DataManager,\n    emitter: EventEmitter,\n    documentUri: string,\n    lines: number[]\n): void {\n    for (const lineNo of lines) {\n        const line = document.lines[lineNo];\n        const packsInfo = data.getPackFolderData(document.pack_segments);\n        let localData: LocalData | undefined;\n        if (packsInfo && document.pack_segments) {\n            localData = {\n                ...packsInfo,\n                current: packsInfo.packnamesmap[document.pack_segments.pack]\n            };\n        }\n        const result = parseCommand(line.text, data.globalData, localData);\n        line.parseInfo = result ? result : false;\n        line.actions = undefined;\n        line.nodes = undefined;\n        emitter.emit(`${documentUri}:${lineNo}`);\n    }\n}\n\nexport function parseDocument(\n    document: FunctionInfo,\n    data: DataManager,\n    emitter: EventEmitter,\n    documentUri: string\n): void {\n    const lines = document.lines.map((_, i) => i);\n    parseLines(document, data, emitter, documentUri, lines);\n}\n","import { EventEmitter } from \"events\";\nimport { promisify } from \"util\";\nimport { shim } from \"util.promisify\";\nshim();\nimport { Interval, IntervalTree } from \"node-interval-tree\";\nimport {\n    CompletionList,\n    createConnection,\n    Diagnostic,\n    DidChangeWatchedFilesNotification,\n    Hover,\n    IPCMessageReader,\n    IPCMessageWriter,\n    Position,\n    TextDocumentPositionParams,\n    TextDocumentSyncKind\n} from \"vscode-languageserver/lib/main\";\n\nimport { computeCompletions } from \"./completions\";\nimport { readSecurity } from \"./data/cache\";\nimport { DataManager } from \"./data/manager\";\nimport { CommandNode } from \"./data/types\";\nimport {\n    actOnSecurity,\n    commandErrorToDiagnostic,\n    followPath,\n    isSuccessful,\n    parseDataPath,\n    runChanges,\n    securityIssues,\n    setup_logging,\n    splitLines\n} from \"./misc-functions\";\nimport { mergeDeep } from \"./misc-functions/third_party/merge-deep\";\nimport { parseDocument, parseLines } from \"./parse\";\nimport {\n    CommandLine,\n    FunctionInfo,\n    MiscInfo,\n    ParseNode,\n    SubAction,\n    WorkspaceSecurity\n} from \"./types\";\n\nconst connection = createConnection(\n    new IPCMessageReader(process),\n    new IPCMessageWriter(process)\n);\nconnection.listen();\n\n//#region Data Storage\nlet manager: DataManager;\nconst documents: Map<string, FunctionInfo> = new Map();\nconst fileErrors = new Map<string, { [group: string]: string }>();\n// Avoids race condition between parsing after change and getting completions\nconst parseCompletionEvents = new EventEmitter();\nlet security: Promise<WorkspaceSecurity>;\n\nlet started = false;\nlet starting = false;\n//#endregion\n\n// For Server Startup logic, see: https://github.com/Microsoft/language-server-protocol/issues/246\nconnection.onInitialize(() => {\n    setup_logging(connection);\n\n    manager = new DataManager();\n    return {\n        capabilities: {\n            completionProvider: {\n                resolveProvider: false\n            },\n            hoverProvider: true,\n            textDocumentSync: {\n                change: TextDocumentSyncKind.Incremental,\n                openClose: true\n            }\n        }\n    };\n});\n\n// Handles the starting of the server\nconnection.onDidChangeConfiguration(async params => {\n    let startinglocal = false;\n    if (!starting) {\n        starting = true;\n        startinglocal = true;\n        global.mcLangSettings = {} as McFunctionSettings;\n        security = readSecurity();\n    }\n    await ensureSecure(params.settings);\n    const reparseall = () => {\n        for (const [uri, doc] of documents.entries()) {\n            parseDocument(doc, manager, parseCompletionEvents, uri);\n            sendDiagnostics(uri);\n        }\n    };\n    if (startinglocal) {\n        const cacheread = await manager.readCache();\n        if (cacheread) {\n            started = true;\n            reparseall();\n        }\n        const getDataResult = await manager.loadGlobalData();\n        if (getDataResult === true) {\n            started = true;\n            reparseall();\n        } else if (!cacheread) {\n            connection.sendNotification(\"mcfunction/shutdown\", getDataResult);\n            return;\n        }\n    }\n});\n\nasync function ensureSecure(settings: {\n    mcfunction: Partial<McFunctionSettings>;\n}): Promise<void> {\n    const secure = await security;\n    const newsettings = mergeDeep(\n        {},\n        global.mcLangSettings,\n        settings.mcfunction\n    ) as McFunctionSettings;\n\n    try {\n        const issues = securityIssues(newsettings, secure);\n        if (issues.length > 0) {\n            // Failed security checkup challenge\n            const safeToContinue = await actOnSecurity(\n                issues,\n                connection,\n                secure\n            );\n            if (!safeToContinue) {\n                connection.sendNotification(\n                    \"mcfunction/shutdown\",\n                    `Shutting down because of insecure settings: '${issues.join(\n                        \"', '\"\n                    )}'`\n                );\n                return;\n            }\n        }\n    } catch (error) {\n        connection.sendNotification(\n            \"mcfunction/shutdown\",\n            `Shutting down because of insecure settings: '${error}'`\n        );\n        return;\n    }\n    global.mcLangSettings = newsettings;\n}\n\nconnection.onDidOpenTextDocument(params => {\n    const uri = params.textDocument.uri;\n    const dataPackSegments = parseDataPath(uri);\n    const parsethis = () => {\n        // Sanity check\n        if (documents.has(uri)) {\n            parseDocument(\n                documents.get(uri) as FunctionInfo,\n                manager,\n                parseCompletionEvents,\n                uri\n            );\n            sendDiagnostics(uri);\n        }\n    };\n    documents.set(uri, {\n        lines: splitLines(params.textDocument.text),\n        pack_segments: dataPackSegments\n    });\n    if (!!dataPackSegments) {\n        manager\n            .readPackFolderData(dataPackSegments.packsFolder)\n            .then(first => {\n                if (isSuccessful(first)) {\n                    connection.client.register(\n                        DidChangeWatchedFilesNotification.type,\n                        {\n                            watchers: [\n                                { globPattern: `${dataPackSegments}**/*` }\n                            ]\n                        }\n                    );\n                }\n                if (started && documents.hasOwnProperty(uri)) {\n                    parsethis();\n                }\n                handleMiscInfo(first.misc);\n            })\n            .catch(e => {\n                mcLangLog(`Getting pack folder data failed for reason: '${e}'`);\n            });\n    }\n    if (started) {\n        parsethis();\n    }\n});\n\nconnection.onDidChangeTextDocument(params => {\n    const uri = params.textDocument.uri;\n    const document = documents.get(uri) as FunctionInfo;\n    const changedlines = runChanges(params, document);\n    if (started) {\n        parseLines(document, manager, parseCompletionEvents, uri, changedlines);\n        sendDiagnostics(uri);\n    }\n});\n\nfunction sendDiagnostics(uri: string): void {\n    const doc = documents.get(uri) as FunctionInfo;\n    const diagnostics: Diagnostic[] = [];\n    for (let line = 0; line < doc.lines.length; line++) {\n        const lineContent = doc.lines[line];\n        if (!!lineContent.parseInfo && !!lineContent.parseInfo.errors) {\n            diagnostics.push(\n                ...lineContent.parseInfo.errors.map(error =>\n                    commandErrorToDiagnostic(error, line)\n                )\n            );\n        }\n    }\n    connection.sendDiagnostics({ uri, diagnostics });\n}\n\nconnection.onDidCloseTextDocument(params => {\n    // Clear diagnostics - might not be needed\n    connection.sendDiagnostics({\n        diagnostics: [],\n        uri: params.textDocument.uri\n    });\n    documents.delete(params.textDocument.uri);\n});\n\nconnection.onDidChangeWatchedFiles(async e => {\n    const result = await manager.handleChanges(e);\n    handleMiscInfo(result.misc);\n});\n\nfunction handleMiscInfo(miscInfos: MiscInfo[]): void {\n    const changedFileErrors = new Set<string>();\n    for (const misc of miscInfos) {\n        if (misc.kind === \"FileError\") {\n            changedFileErrors.add(misc.filePath);\n            const value = fileErrors.get(misc.filePath);\n            if (value) {\n                fileErrors.set(misc.filePath, {\n                    ...value,\n                    group: misc.message\n                });\n            } else {\n                fileErrors.set(misc.filePath, {\n                    group: misc.message\n                });\n            }\n        }\n        if (misc.kind === \"ClearError\") {\n            changedFileErrors.add(misc.filePath);\n            const group = misc.group;\n            if (group) {\n                const value = fileErrors.get(misc.filePath);\n                if (value) {\n                    const { group: _, ...rest } = value;\n                    fileErrors.set(misc.filePath, { ...rest });\n                }\n            } else {\n                fileErrors.delete(misc.filePath);\n            }\n        }\n    }\n    for (const uri of changedFileErrors) {\n        const value = fileErrors.get(uri);\n        if (value) {\n            const diagnostics: Diagnostic[] = [];\n            for (const group of Object.keys(value)) {\n                diagnostics.push({\n                    message: value[group],\n                    range: {\n                        end: { line: 0, character: 0 },\n                        start: { line: 0, character: 0 }\n                    }\n                });\n            }\n            connection.sendDiagnostics({ uri, diagnostics });\n        }\n    }\n}\n\nconnection.onCompletion(params => {\n    const doc = documents.get(params.textDocument.uri) as FunctionInfo;\n    const line = doc.lines[params.position.line];\n    const computeCompletionsLocal = () =>\n        computeCompletions(\n            params.position.line,\n            params.position.character,\n            doc,\n            manager\n        );\n    if (!started) {\n        return [];\n    }\n    if (line.hasOwnProperty(\"parseInfo\")) {\n        return computeCompletionsLocal();\n    } else {\n        return promisify(cb =>\n            parseCompletionEvents.once(\n                `${params.textDocument.uri}:${params.position.line}`,\n                cb\n            )\n        )().then<CompletionList>(computeCompletionsLocal);\n    }\n});\n\nconnection.onHover(params => {\n    if (started) {\n        const docLine = getLine(params);\n        if (docLine) {\n            function computeIntervalHovers<T extends Interval>(\n                intervals: T[],\n                commandLine: CommandLine,\n                line: number,\n                map: (intervals: T[]) => Hover[\"contents\"]\n            ): Hover {\n                const end: Position = {\n                    character: intervals.reduce(\n                        (acc, v) => Math.max(acc, v.high),\n                        0\n                    ),\n                    line\n                };\n                const start: Position = {\n                    character: intervals.reduce(\n                        (acc, v) => Math.min(acc, v.low),\n                        commandLine.text.length\n                    ),\n                    line\n                };\n                return {\n                    contents: map(intervals),\n                    range: { start, end }\n                };\n            }\n            const hovers = getActionsOfKind(docLine, params.position, \"hover\");\n            if (hovers.length > 0) {\n                return computeIntervalHovers(\n                    hovers,\n                    docLine,\n                    params.position.line,\n                    i => i.map(v => v.data)\n                );\n            } else {\n                const tree = getNodeTree(docLine);\n                if (tree) {\n                    const matching = tree.search(\n                        params.position.character,\n                        params.position.character\n                    );\n                    if (matching.length > 0) {\n                        return computeIntervalHovers(\n                            matching,\n                            docLine,\n                            params.position.line,\n                            i =>\n                                i.map<string>(node => {\n                                    const data = followPath(\n                                        manager.globalData.commands,\n                                        node.path\n                                    ) as CommandNode;\n                                    return `${\n                                        data.type === \"literal\"\n                                            ? \"literal\"\n                                            : `\\`${data.parser}\\` parser`\n                                    } on path '${node.path.join(\", \")}'`;\n                                })\n                        );\n                    }\n                }\n            }\n        }\n    }\n    return undefined;\n});\n\nfunction getLine(params: TextDocumentPositionParams): CommandLine | undefined {\n    const doc = documents.get(params.textDocument.uri);\n    if (doc) {\n        const line = doc.lines[params.position.line];\n\n        return line;\n    }\n    return undefined;\n}\n\nfunction getActionsOfKind(\n    line: CommandLine,\n    position: Position,\n    kind: SubAction[\"type\"]\n): SubAction[] {\n    if (line.parseInfo) {\n        if (!line.actions) {\n            line.actions = new IntervalTree();\n            for (const action of line.parseInfo.actions) {\n                line.actions.insert(action);\n            }\n        }\n        const tree = line.actions;\n        return tree\n            .search(position.character, position.character)\n            .filter(v => v.type === kind);\n    }\n    return [];\n}\n\nfunction getNodeTree(line: CommandLine): IntervalTree<ParseNode> | undefined {\n    if (line.nodes) {\n        return line.nodes;\n    }\n    if (line.parseInfo) {\n        const tree = new IntervalTree<ParseNode>();\n        for (const node of line.parseInfo.nodes) {\n            tree.insert(node);\n        }\n        return tree;\n    }\n    return undefined;\n}\n"]}